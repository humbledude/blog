<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>돌아서면 까먹는다</title>
    <link>https://humbledude.github.io/blog/</link>
    
    <atom:link href="https://humbledude.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 16 Nov 2022 16:39:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>우리 애들은 공부 못해도 서울대 가나요?</title>
      <link>https://humbledude.github.io/blog/2022/11/17/university/</link>
      <guid>https://humbledude.github.io/blog/2022/11/17/university/</guid>
      <pubDate>Wed, 16 Nov 2022 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;자녀 교육에 근심 걱정이 많은 친구들을 만날때마다 내가 하는말,,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이제 출산율이 적어서 우리 애들 대학 갈때쯤이면 공부 잘 못해도 그냥 대학 갈껄~?&lt;br&gt;우리 이전 세대도 대학 정원에 비해 사람이 적었잖아&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<p>자녀 교육에 근심 걱정이 많은 친구들을 만날때마다 내가 하는말,,</p><blockquote><p>이제 출산율이 적어서 우리 애들 대학 갈때쯤이면 공부 잘 못해도 그냥 대학 갈껄~?<br>우리 이전 세대도 대학 정원에 비해 사람이 적었잖아<br>그때도 대학 쉽게 간거 같던데?<br>그냥 놀려 놀자</p></blockquote><p>그렇게 여러 친구들을 악의 구렁텅이로 집어 넣었는데, 이제 내가 학부모가 될 차례가 되었다.<br>그래서 이제 와서 좀 따져보고 싶어졌다. 정말로 우리 애들은 대충 공부해도 서울대 갈수 있을까?</p><h2 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h2><p>이 글의 내용은 반 농담 + 반 진담 으로써, 너무 죽자고 달려들지 맙시다<br>데이터 드리븐 농담 정도로 받아들입시다</p><h2 id="어떻게-구해볼-것인가"><a href="#어떻게-구해볼-것인가" class="headerlink" title="어떻게 구해볼 것인가?"></a>어떻게 구해볼 것인가?</h2><p>나의 가설은 아래와 같다</p><blockquote><p>우리 자녀가 입시할때는, 정원 대비 지원자가 적기 때문에, 경쟁률이 확연히 낮아질 것이다<br>경쟁률이 낮아진다면, 경쟁률이 낮아진 만큼 열심히 공부 안해도 된다!!</p></blockquote><p>필요한 데이터는 아래와 같다 (내 자녀가 입시할때는 2035년으로 본다)</p><ul><li>대학 입학 정원 : 최신 측정 값, 2035년 추정치</li><li>대학 입학 지원자수 추정치 : 최신 측정 값, 2035년 추정치</li><li>경쟁률 = 대학 입학 지원자수 / 대학 입학 정원</li><li>합격률 (경쟁률의 역수, 복잡한거 떼고, 지원자중 상위 몇프로가 합격이냐) = 대학 입학 정원 / 대학 입학 지원자수</li></ul><p>요렇게 계산 해서 현재 대비 2035년에 낮아진 경쟁률만큼, 높아진 합격률만큼 널널하게 놀게 하면 되겠다!!!!</p><h2 id="떨리는-마음으로-일단-대학-입학-정원과-지원자수를-털어본다"><a href="#떨리는-마음으로-일단-대학-입학-정원과-지원자수를-털어본다" class="headerlink" title="떨리는 마음으로 일단 대학 입학 정원과 지원자수를 털어본다"></a>떨리는 마음으로 일단 대학 입학 정원과 지원자수를 털어본다</h2><p>여기저기 기웃거려보았으나,,<br>아래 자료에서 대학 정원 / 지원자 관련 데이터를 찾을 수 있었다</p><ol><li><a href="https://kess.kedi.re.kr/mobile/stats/school?menuCd=0102&cd=5536&survSeq=2021&itemCode=01&menuId=m_01020902&uppCd1=01020902&uppCd2=01020902&flag=A">2021 대학 계열별 입학정원 입학자 (신입생 충원률) - 교육통계서비스</a></li></ol><img src="/blog/2022/11/17/university/Untitled.png" class="" title="교육통계서비스"><ol start="2"><li><a href="https://data.seoul.go.kr/dataList/210/S/2/datasetView.do">서울시 대학교 통계 - 서울 열린데이터 광장</a></li></ol><img src="/blog/2022/11/17/university/Untitled%201.png" class="" title="서울 열린 데이터 광장"><p>그런데.. 1번은 연도별 추이를 보여주지는 않고, 해당 년도를 각각 입력해서 구해야 한다. (귀찮..)<br>2번은 서울 데이터라서 서울 소재 대학에 대한 데이터만 나오는 대신, 연도별 추이가 나온다!!<br>그렇다면 그냥 2번 데이터를 써서 서울 소재 대학을 대상으로 계산을 한다.<br>일일이 페이지를 뒤져가며 데이터를 찾기 귀찮으니까..<br>(대학이 서울에만 있나~ 이런 소리는 하지 말자)</p><p>아무튼 2번 데이터를 긁어온담에 요리조리 굴려서 표를 만들었다</p><ul><li>입학자수는 입학정원이라고 쳐보겠다</li><li>대략 연도는 입학연도이고, 수능은 그 전해에 본 그런 데이터다.</li><li>경쟁률은 xx : 1 로 읽으면 되겠군</li><li>합격률을 보면 상위 몇프로가 합격했는지 알수 있겠어</li></ul><table><thead><tr><th>연도</th><th>입학지원자수</th><th>입학자수</th><th>경쟁률</th><th>합격률</th></tr></thead><tbody><tr><td>2000</td><td>445398</td><td>77690</td><td>5.73</td><td>17.44%</td></tr><tr><td>2001</td><td>509490</td><td>77431</td><td>6.58</td><td>15.20%</td></tr><tr><td>2002</td><td>609722</td><td>76245</td><td>8.00</td><td>12.50%</td></tr><tr><td>2003</td><td>557143</td><td>76728</td><td>7.26</td><td>13.77%</td></tr><tr><td>2004</td><td>603545</td><td>78613</td><td>7.68</td><td>13.03%</td></tr><tr><td>2005</td><td>679670</td><td>75650</td><td>8.98</td><td>11.13%</td></tr><tr><td>2006</td><td>737984</td><td>76120</td><td>9.70</td><td>10.31%</td></tr><tr><td>2007</td><td>826201</td><td>75669</td><td>10.92</td><td>9.16%</td></tr><tr><td>2008</td><td>794061</td><td>73674</td><td>10.78</td><td>9.28%</td></tr><tr><td>2009</td><td>923072</td><td>74467</td><td>12.40</td><td>8.07%</td></tr><tr><td>2010</td><td>1026828</td><td>76696</td><td>13.39</td><td>7.47%</td></tr><tr><td>2011</td><td>1263733</td><td>76527</td><td>16.51</td><td>6.06%</td></tr><tr><td>2012</td><td>1432149</td><td>82647</td><td>17.33</td><td>5.77%</td></tr><tr><td>2013</td><td>1093516</td><td>81216</td><td>13.46</td><td>7.43%</td></tr><tr><td>2014</td><td>1080774</td><td>83454</td><td>12.95</td><td>7.72%</td></tr><tr><td>2015</td><td>1122298</td><td>83446</td><td>13.45</td><td>7.44%</td></tr><tr><td>2016</td><td>1139364</td><td>83883</td><td>13.58</td><td>7.36%</td></tr><tr><td>2017</td><td>1115456</td><td>83395</td><td>13.38</td><td>7.48%</td></tr><tr><td>2018</td><td>1120818</td><td>83729</td><td>13.39</td><td>7.47%</td></tr><tr><td>2019</td><td>1104037</td><td>83541</td><td>13.22</td><td>7.57%</td></tr><tr><td>2020</td><td>1066515</td><td>83875</td><td>12.72</td><td>7.86%</td></tr><tr><td>2021</td><td>982740</td><td>84771</td><td>11.59</td><td>8.63%</td></tr></tbody></table><p>데이터를 보니.. 희안하게 2000년도에는 다들 서울에 지원 잘 안했나보다. 경쟁률이 낮다.<br>나때가 그래도 대학가기 쉬웠던건가… ㅠㅠ<br>2012년에 지원자가 최고점을 찍은 이후로 점점 지원자가 줄고 있다.<br>대략 2012 년도 대학가신분들이 최고 고통받으신듯.. (왜죠)</p><p>이제 2035년을 계산해야 되는데..<br>나의 가설에 의하면, <code>출산률 저조 → 입시 경쟁률 개선</code> 이기 때문에, 출산률이 반영되면 되겠다.<br>그러면 인구 통계를 참조해서, 당해 입시를 볼 애들의 인구수와 지원자의 상관관계를 구해보겠다 (멋짐)</p><h2 id="인구-통계-이리오너라"><a href="#인구-통계-이리오너라" class="headerlink" title="인구 통계 이리오너라~"></a>인구 통계 이리오너라~</h2><p>요것저것 뒤져보니, 아래 행정안전부 데이터에서 2021년 기준의 인구수를 구할 수 있었다</p><p><a href="https://jumin.mois.go.kr/">주민등록 인구 통계 (행정안전부)</a></p><ul><li>2021년 12월 현재 출생년도별 인구수</li></ul><table><thead><tr><th>출생년도</th><th>인구수</th></tr></thead><tbody><tr><td>1981</td><td>837,928</td></tr><tr><td>1982</td><td>820,317</td></tr><tr><td>1983</td><td>746,777</td></tr><tr><td>1984</td><td>660,870</td></tr><tr><td>1985</td><td>651,979</td></tr><tr><td>1986</td><td>627,431</td></tr><tr><td>1987</td><td>617,636</td></tr><tr><td>1988</td><td>625,794</td></tr><tr><td>1989</td><td>630,872</td></tr><tr><td>1990</td><td>640,224</td></tr><tr><td>1991</td><td>701,535</td></tr><tr><td>1992</td><td>724,013</td></tr><tr><td>1993</td><td>708,889</td></tr><tr><td>1994</td><td>712,085</td></tr><tr><td>1995</td><td>706,235</td></tr><tr><td>1996</td><td>683,379</td></tr><tr><td>1997</td><td>669,509</td></tr><tr><td>1998</td><td>638,093</td></tr><tr><td>1999</td><td>618,217</td></tr><tr><td>2000</td><td>637,555</td></tr><tr><td>2001</td><td>557,948</td></tr><tr><td>2002</td><td>493,456</td></tr><tr><td>2003</td><td>492,266</td></tr><tr><td>2004</td><td>473,465</td></tr><tr><td>2005</td><td>436,095</td></tr><tr><td>2006</td><td>449,838</td></tr><tr><td>2007</td><td>496,081</td></tr><tr><td>2008</td><td>469,101</td></tr><tr><td>2009</td><td>448,481</td></tr><tr><td>2010</td><td>473,997</td></tr><tr><td>2011</td><td>476,536</td></tr><tr><td>2012</td><td>490,049</td></tr><tr><td>2013</td><td>441,672</td></tr><tr><td>2014</td><td>440,866</td></tr><tr><td>2015</td><td>444,555</td></tr><tr><td>2016</td><td>412,739</td></tr><tr><td>2017</td><td>363,613</td></tr><tr><td>2018</td><td>332,157</td></tr><tr><td>2019</td><td>306,120</td></tr><tr><td>2020</td><td>274,633</td></tr><tr><td>2021</td><td>253,946</td></tr></tbody></table><p>연령별 인구수가 나왔으니, 입학 지원자와 비교해 보자.<br>대략 2021년 지원자 982,740 명이고,<br>2021년에 입학하시려면, 2020년에 고3이고, 2019년에 고2고,,, 태어난 해는 2002 년이다<br>대략 입학자수 표의 연도에서 19를 빼면 된다</p><p>요렇게 해서 베이스 데이터를 만들었다</p><table><thead><tr><th>출생년도</th><th>인구수</th><th>대학 입학 년도</th><th>입학지원자수</th><th>입학자수</th><th>경쟁률</th><th>합격률</th></tr></thead><tbody><tr><td>1981</td><td>837,928</td><td>2000</td><td>445398</td><td>77690</td><td>5.73</td><td>17.44%</td></tr><tr><td>1982</td><td>820,317</td><td>2001</td><td>509490</td><td>77431</td><td>6.58</td><td>15.20%</td></tr><tr><td>1983</td><td>746,777</td><td>2002</td><td>609722</td><td>76245</td><td>8.00</td><td>12.50%</td></tr><tr><td>1984</td><td>660,870</td><td>2003</td><td>557143</td><td>76728</td><td>7.26</td><td>13.77%</td></tr><tr><td>1985</td><td>651,979</td><td>2004</td><td>603545</td><td>78613</td><td>7.68</td><td>13.03%</td></tr><tr><td>1986</td><td>627,431</td><td>2005</td><td>679670</td><td>75650</td><td>8.98</td><td>11.13%</td></tr><tr><td>1987</td><td>617,636</td><td>2006</td><td>737984</td><td>76120</td><td>9.70</td><td>10.31%</td></tr><tr><td>1988</td><td>625,794</td><td>2007</td><td>826201</td><td>75669</td><td>10.92</td><td>9.16%</td></tr><tr><td>1989</td><td>630,872</td><td>2008</td><td>794061</td><td>73674</td><td>10.78</td><td>9.28%</td></tr><tr><td>1990</td><td>640,224</td><td>2009</td><td>923072</td><td>74467</td><td>12.40</td><td>8.07%</td></tr><tr><td>1991</td><td>701,535</td><td>2010</td><td>1026828</td><td>76696</td><td>13.39</td><td>7.47%</td></tr><tr><td>1992</td><td>724,013</td><td>2011</td><td>1263733</td><td>76527</td><td>16.51</td><td>6.06%</td></tr><tr><td>1993</td><td>708,889</td><td>2012</td><td>1432149</td><td>82647</td><td>17.33</td><td>5.77%</td></tr><tr><td>1994</td><td>712,085</td><td>2013</td><td>1093516</td><td>81216</td><td>13.46</td><td>7.43%</td></tr><tr><td>1995</td><td>706,235</td><td>2014</td><td>1080774</td><td>83454</td><td>12.95</td><td>7.72%</td></tr><tr><td>1996</td><td>683,379</td><td>2015</td><td>1122298</td><td>83446</td><td>13.45</td><td>7.44%</td></tr><tr><td>1997</td><td>669,509</td><td>2016</td><td>1139364</td><td>83883</td><td>13.58</td><td>7.36%</td></tr><tr><td>1998</td><td>638,093</td><td>2017</td><td>1115456</td><td>83395</td><td>13.38</td><td>7.48%</td></tr><tr><td>1999</td><td>618,217</td><td>2018</td><td>1120818</td><td>83729</td><td>13.39</td><td>7.47%</td></tr><tr><td>2000</td><td>637,555</td><td>2019</td><td>1104037</td><td>83541</td><td>13.22</td><td>7.57%</td></tr><tr><td>2001</td><td>557,948</td><td>2020</td><td>1066515</td><td>83875</td><td>12.72</td><td>7.86%</td></tr><tr><td>2002</td><td>493,456</td><td>2021</td><td>982740</td><td>84771</td><td>11.59</td><td>8.63%</td></tr><tr><td>2003</td><td>492,266</td><td>2022</td><td></td><td></td><td></td><td></td></tr><tr><td>2004</td><td>473,465</td><td>2023</td><td></td><td></td><td></td><td></td></tr><tr><td>2005</td><td>436,095</td><td>2024</td><td></td><td></td><td></td><td></td></tr><tr><td>2006</td><td>449,838</td><td>2025</td><td></td><td></td><td></td><td></td></tr><tr><td>2007</td><td>496,081</td><td>2026</td><td></td><td></td><td></td><td></td></tr><tr><td>2008</td><td>469,101</td><td>2027</td><td></td><td></td><td></td><td></td></tr><tr><td>2009</td><td>448,481</td><td>2028</td><td></td><td></td><td></td><td></td></tr><tr><td>2010</td><td>473,997</td><td>2029</td><td></td><td></td><td></td><td></td></tr><tr><td>2011</td><td>476,536</td><td>2030</td><td></td><td></td><td></td><td></td></tr><tr><td>2012</td><td>490,049</td><td>2031</td><td></td><td></td><td></td><td></td></tr><tr><td>2013</td><td>441,672</td><td>2032</td><td></td><td></td><td></td><td></td></tr><tr><td>2014</td><td>440,866</td><td>2033</td><td></td><td></td><td></td><td></td></tr><tr><td>2015</td><td>444,555</td><td>2034</td><td></td><td></td><td></td><td></td></tr><tr><td>2016</td><td>412,739</td><td>2035</td><td></td><td></td><td></td><td></td></tr><tr><td>2017</td><td>363,613</td><td>2036</td><td></td><td></td><td></td><td></td></tr><tr><td>2018</td><td>332,157</td><td>2037</td><td></td><td></td><td></td><td></td></tr><tr><td>2019</td><td>306,120</td><td>2038</td><td></td><td></td><td></td><td></td></tr><tr><td>2020</td><td>274,633</td><td>2039</td><td></td><td></td><td></td><td></td></tr><tr><td>2021</td><td>253,946</td><td>2040</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>요걸 베이스로 미래 데이터를 추정 해볼꺼다 (출생년도 2003 년 이후부터의 데이터 빈칸을 채워 볼것이다)</p><h2 id="두근두근-어떻게-숫자를-가지고-장난을-쳐야-우리-자녀들을-놀게-할수-있을까"><a href="#두근두근-어떻게-숫자를-가지고-장난을-쳐야-우리-자녀들을-놀게-할수-있을까" class="headerlink" title="두근두근~ 어떻게 숫자를 가지고 장난을 쳐야 우리 자녀들을 놀게 할수 있을까.."></a>두근두근~ 어떻게 숫자를 가지고 장난을 쳐야 우리 자녀들을 놀게 할수 있을까..</h2><p>사실 나 할줄아는거 linear regression 밖에 없다<br>머신러닝 아무리 공부해도 다른건 잘 모르겠더라..<br>그리고 지금 뭐 대단한거 구하는것도 아니고.. (쫌 틀려도 상관없기도 하고 ㅎㅎ)<br>그냥 linear regression 돌려도 될꺼 같다. 구글 콜랩을 가동하라~~!!</p><h3 id="재수-삼수"><a href="#재수-삼수" class="headerlink" title="재수 삼수..???"></a>재수 삼수..???</h3><p>얾.. 근데 2002년 태어나신분들이 493,456 명, 2021년 입시지원자 982,740 명인데..<br>2002년에 태어난분보다 서울 소재 대학 입시 지원자가 더 많다 (왠열)<br>일단.. 재수 삼수의 비율은 일정하다고 보겠다. 쉽게 해야지.<br>재수삼수 등등 다 포함해야 되나보다.. 이거 어쩌지 재도전 n차 인원들 어케 구하지..<br>재도전 n차 인원들을 구하지 말고, 그냥 linear regression 의 x 의 한 축으로 넣어버리도록 하겠다.</p><p>대략 삼수까지 넣어본다</p><p>(사수는.. 그냥 적을꺼 같고.. 하니까 ㅎㅎ)</p><img src="/blog/2022/11/17/university/Untitled%202.png" class="" title="재수삼수사수 colab"><h3 id="2012-년-전에는-대학가기-쉬웠다메-돌날라온다"><a href="#2012-년-전에는-대학가기-쉬웠다메-돌날라온다" class="headerlink" title="2012 년 전에는 대학가기 쉬웠다메..?? (돌날라온다~~)"></a>2012 년 전에는 대학가기 쉬웠다메..?? (돌날라온다~~)</h3><p>아까 봤듯이 2012년도 전에는 오히려 지원자수가 증가하는 추세였다. (왜죠)<br>나의 예측은 인구수에 따라 계속 지원자수가 줄어들것이다.. 라는 것이기 때문에, 2012년 이후의 데이터만 쓰려고 한다</p><h3 id="근데-입학-정원은"><a href="#근데-입학-정원은" class="headerlink" title="근데.. 입학 정원은..?"></a>근데.. 입학 정원은..?</h3><p>대학 입학정원은 인구수와 관계가 있을까? 상식적으로는 입시 인구수와 비례하여 입시 인구가 줄어들면 입학 정원도 줄꺼 같다.<br>그런데 일단 2012년 이후는 입학 인구수가 줄어듬에도 불구하고 입학 정원이 증가하는 추세다.<br>그러니, 일단은 이 추세 그대로 이어진다고 하고 계산해보도록 하겠다.<br>(하지만 2035년까지 대학 입학 정원이 증가하는 추세가 이어질꺼라는 상식적인 기대가 되지는 않는다.)</p><h3 id="그럼-이제-코드-돌려보겠습니다"><a href="#그럼-이제-코드-돌려보겠습니다" class="headerlink" title="그럼 이제 코드 돌려보겠습니다"></a>그럼 이제 코드 돌려보겠습니다</h3><p>사실 나는 데이터 엔지니어쪽에 더 가까워서 (변명중..) 머신러닝의 제대로된 절차는 잘 모른다.<br>그냥 fit 하고 predict 해서 쓸줄밖에.. ㅎㅎㅎㅎ<br>입학지원자수를 구할때는 고삼 인구수, 재수, 삼수 인구수를 X 로 넣고요,<br>입학자수를 구할때는 그냥 대학 입학 년도를 넣었다 (y 값만 있는 데이터의 추세를 구하는법 아시는분 지도 부탁드립니다)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x1_param_names &#x3D; [&#39;인구수&#39;, &#39;재수&#39;, &#39;삼수&#39;]</span><br><span class="line">x2_param_names &#x3D; [&#39;대학 입학 년도&#39;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df_source &#x3D; df.iloc[14:24]</span><br><span class="line"></span><br><span class="line">X1 &#x3D; df_source[x1_param_names]</span><br><span class="line">Y1 &#x3D; df_source[[&#39;입학지원자수&#39;]]</span><br><span class="line">lr1 &#x3D; LinearRegression(positive&#x3D;True)</span><br><span class="line">lr1.fit(X1, Y1)</span><br><span class="line"></span><br><span class="line">X2 &#x3D; df_source[x2_param_names]</span><br><span class="line">Y2 &#x3D; df_source[[&#39;입학자수&#39;]]</span><br><span class="line">lr2 &#x3D; LinearRegression(positive&#x3D;True)</span><br><span class="line">lr2.fit(X2, Y2)</span><br></pre></td></tr></table></figure><p>그리고 그~냥 predict 돌려서 데이터를 합성했다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df_output &#x3D; df.iloc[3:]</span><br><span class="line"></span><br><span class="line">x1 &#x3D; df_output[x1_param_names]</span><br><span class="line">y1 &#x3D; lr1.predict(x1)</span><br><span class="line">x2 &#x3D; df_output[x2_param_names]</span><br><span class="line">y2 &#x3D; lr2.predict(x2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df_output[&#39;입학지원자수_predicted&#39;] &#x3D; y1</span><br><span class="line">df_output[&#39;입학자수_predicted&#39;] &#x3D; y2</span><br><span class="line">df_output[&#39;경쟁률_predicted&#39;] &#x3D; df_output[&#39;입학지원자수_predicted&#39;] &#x2F; df_output[&#39;입학자수_predicted&#39;]</span><br><span class="line">df_output[&#39;합격률_predicted&#39;] &#x3D; df_output[&#39;입학자수_predicted&#39;] &#x2F; df_output[&#39;입학지원자수_predicted&#39;]</span><br></pre></td></tr></table></figure><h3 id="두근두근-결과-발표"><a href="#두근두근-결과-발표" class="headerlink" title="두근두근~~ 결과 발표"></a>두근두근~~ 결과 발표</h3><img src="/blog/2022/11/17/university/Untitled%205.png" class="" title="예측결과"><img src="/blog/2022/11/17/university/Untitled%206.png" class="" title="예측결과 그래프"><p>(폰트가 깨졌으나, 합격률_predicted 의 그래프인 것이다.)</p><p>대략 현재 8.6% 의 합격률인것이 2016년생인 내 딸래미 입시볼때는 10.43% 까지밖에 개선이 안되는구만.. ㅠㅠ<br>쪼끔밖에 더 못놀겠다 싶다..<br>(2019년생 아들래미 12.68%.. 넌 좀 더 놀아라)</p><h2 id="사족-정말-쫌만-놀아야-합니까-ㅠㅠ"><a href="#사족-정말-쫌만-놀아야-합니까-ㅠㅠ" class="headerlink" title="사족.. 정말 쫌만 놀아야 합니까 ㅠㅠ"></a>사족.. 정말 쫌만 놀아야 합니까 ㅠㅠ</h2><p>위 결과는 서울소재 대학에 대한 계산을 했는데, 좋은 대학이 무조건 서울에 있는것도 아니기 때문에, 서울 소재가 아닌 대학까지 합친다면 좀더 널널 할 것이다~ 라고 말하고 싶다 (야호 더놀자~~)</p><p>그러나 대학의 정원이 현재는 증가하는 추세로 보이지만, 출산률 감소에 따라 학생이 현저히 줄고 그에따라 대학의 정원이 조절 될 것이라는 상식적인 예측이 가능하다 (그렇지 않아도 <code>2021년 대학 기본역량 진단</code>하고 난리가 났었다)</p><p>개인적으로는 우리 세대나 대학대학 했지, 내 아이들이 대학갈 나이가 되면 더 다양한 진로가 개발되지 않을까 하는 생각이 있다. (그 새로운 진로들이 다 xx 대학이라는 이름으로 만들어질지는 또 두고 볼 일이다.)</p><p>아무튼 오늘은 재밌게 놀자 얘들아~</p><h2 id="코드-amp-데이터는-아래-링크에서-확인-가능해요"><a href="#코드-amp-데이터는-아래-링크에서-확인-가능해요" class="headerlink" title="코드 &amp; 데이터는 아래 링크에서 확인 가능해요"></a>코드 &amp; 데이터는 아래 링크에서 확인 가능해요</h2><ul><li><a href="https://colab.research.google.com/drive/1Wwz9dJBQi9lO-b8tFoBkAnLb76WA4FvJ?usp=sharing">colab 노트북</a></li><li><a href="https://docs.google.com/spreadsheets/d/1D3h3cp1JzSHv4vA8sdhj_DxRgIQkCd3O6logsuiV8cI/edit?usp=sharing">google sheet</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D/">데이터 분석</category>
      
      <category domain="https://humbledude.github.io/blog/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%93%9C%EB%A6%AC%EB%B8%90-%EB%86%8D%EB%8B%B4/">데이터 드리븐 농담</category>
      
      
      <comments>https://humbledude.github.io/blog/2022/11/17/university/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pyenv 동작방식 이해를 위한 실험</title>
      <link>https://humbledude.github.io/blog/2021/03/31/pyenv-experiment/</link>
      <guid>https://humbledude.github.io/blog/2021/03/31/pyenv-experiment/</guid>
      <pubDate>Wed, 31 Mar 2021 07:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;나는 원래 pyenv ( + pyenv-virtualenv) 를 사용해서 python 개발환경의 dependency 를 관리 해 왔다.&lt;br&gt;(이걸 여기다 깔았었나 .. virtualenv 에다 깔았었나…)&lt;br&gt;그러던 참에 poetry 라는걸 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>나는 원래 pyenv ( + pyenv-virtualenv) 를 사용해서 python 개발환경의 dependency 를 관리 해 왔다.<br>(이걸 여기다 깔았었나 .. virtualenv 에다 깔았었나…)<br>그러던 참에 poetry 라는걸 알게 되어 써보려고 했는데..<br>pyenv 도 정확히 이해가 안되는데 여기에 또 저걸 쓰면 과연 잘 할수 있을까? 싶어서, 일단 pyenv 의 동작방식을 명확히 하기 위한 실험을 해 봤다.</p><p>혹시 pyenv 의 동작 방식에 대한 나와같은 혼미함을 가진 분이 있다면 정리된 글이 도움이 되길 바라며..</p><h2 id="기본-테스트-환경"><a href="#기본-테스트-환경" class="headerlink" title="기본 테스트 환경"></a>기본 테스트 환경</h2><ul><li>mac catalina 10.15.7</li><li>pyenv 1.2.20 설치됨 + 각종 python 버전들 이미 설치되어 사용중</li><li>pyenv 설치 경로 : /Users/joshua/.pyenv</li></ul><h2 id="첫번째-테스트-환경-clean-python-상태"><a href="#첫번째-테스트-환경-clean-python-상태" class="headerlink" title="첫번째 테스트 환경 - clean python 상태"></a>첫번째 테스트 환경 - clean python 상태</h2><ol><li><code>pyenv install 3.6.10</code> 으로 python 3.6.10 클린 인스톨</li><li><code>pyenv global 3.6.10</code> 지정</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python 3.6.10</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> python</span><br><span class="line">/Users/joshua/.pyenv/shims/python</span><br><span class="line"></span><br><span class="line">$ pip --version</span><br><span class="line">pip 18.1 from /Users/joshua/.pyenv/versions/3.6.10/lib/python3.6/site-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> pip</span><br><span class="line">/Users/joshua/.pyenv/shims/pip</span><br><span class="line"></span><br><span class="line">$ pyenv <span class="built_in">which</span> pip</span><br><span class="line">/Users/joshua/.pyenv/versions/3.6.10/bin/pip</span><br></pre></td></tr></table></figure><p>pyenv 의 내부 구조를 좀 아시는분은 알겠지만, 각종 python 관련 명령어들은 shims 아래 디렉토리에서 가져다 쓰게 된다.<br>shims 디렉토리를 가보면 이전에 각종 python 버전들을 사용하면서 설치했던 binary 명령어들이 다 들어있다.<br>각 shims 아래의 명령어를 실행해보면, 현재 python 버전에 따라 다르게 동작한다.</p><p>다른 python 버전에 깔려있는 jupyter 노트북 명령어를 한번 실행해봤다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter</span><br><span class="line">pyenv: jupyter: <span class="built_in">command</span> not found</span><br><span class="line"></span><br><span class="line">The `jupyter<span class="string">&#x27; command exists in these Python versions:</span></span><br><span class="line"><span class="string">  3.6.11</span></span><br><span class="line"><span class="string">  3.6.11/envs/project1</span></span><br><span class="line"><span class="string">  3.6.11/envs/project2</span></span><br><span class="line"><span class="string">  project1</span></span><br><span class="line"><span class="string">  project2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note: See &#x27;</span>pyenv <span class="built_in">help</span> global<span class="string">&#x27; for tips on allowing both</span></span><br><span class="line"><span class="string">      python2 and python3 to be found.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ pyenv whence jupyter</span></span><br><span class="line"><span class="string">3.6.11</span></span><br><span class="line"><span class="string">3.6.11/envs/project1</span></span><br><span class="line"><span class="string">3.6.11/envs/project2</span></span><br><span class="line"><span class="string">project1</span></span><br><span class="line"><span class="string">project2</span></span><br></pre></td></tr></table></figure><p>오호라~ 현재 python 버전에 깔리지 않은것은 실행이 안되고, 대신 어디 깔려있는지 알려주는구만~<br><code>pyenv whence</code> 기능으로 어떤 명령어가 어느 python 환경에 설치 되어있는지 알수 있었다.</p><p>그리고 당연히 import 도 안된다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line"></span><br><span class="line">Python 3.6.10 (default, Mar 31 2021, 11:22:54)</span><br><span class="line">[GCC Apple LLVM 12.0.0 (clang-1200.0.32.28)] on darwin</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import jupyter</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;jupyter&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="두번째-테스트-환경-python-이-어느정도-활용된-dirty-상태"><a href="#두번째-테스트-환경-python-이-어느정도-활용된-dirty-상태" class="headerlink" title="두번째 테스트 환경 - python 이 어느정도 활용된 dirty 상태"></a>두번째 테스트 환경 - python 이 어느정도 활용된 dirty 상태</h2><ol><li><code>pyenv global 3.6.10</code> 로 위에서 clean install 된 3.6.10 이 global로 설정됨</li><li><code>pyenv shell 3.6.11</code> 기존에 마구마구 활용했던 3.6.11 을 shell 에서 사용하기</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python 3.6.11</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> python</span><br><span class="line">/Users/joshua/.pyenv/shims/python</span><br><span class="line"></span><br><span class="line">$ pip --version</span><br><span class="line">pip 18.1 from /Users/joshua/.pyenv/versions/3.6.11/Python.framework/Versions/3.6/lib/python3.6/site-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> pip</span><br><span class="line">/Users/joshua/.pyenv/shims/pip</span><br><span class="line"></span><br><span class="line">$ pyenv <span class="built_in">which</span> pip</span><br><span class="line">/Users/joshua/.pyenv/versions/3.6.11/bin/pip</span><br></pre></td></tr></table></figure><p>global 이 뭐가 되었든, 현재 지정된 python 3.6.11 기준으로 동작한다.</p><p>여기 3.6.11 은 내가 기존에 쓰던거라 이것 저것 깔려있는데, 그중에 jupyter 를 한번 테스트에 써봤다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter</span><br><span class="line">usage: jupyter [-h] [--version] [--config-dir] [--data-dir] [--runtime-dir]</span><br><span class="line">               [--paths] [--json]</span><br><span class="line">               [subcommand]</span><br><span class="line">jupyter: error: one of the arguments --version subcommand --config-dir --data-dir --runtime-dir --paths is required</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> jupyter</span><br><span class="line">/Users/joshua/.pyenv/shims/jupyter</span><br><span class="line"></span><br><span class="line">$ pyenv <span class="built_in">which</span> jupyter</span><br><span class="line">/Users/joshua/.pyenv/versions/3.6.11/bin/jupyter</span><br><span class="line"></span><br><span class="line">$ python</span><br><span class="line">Python 3.6.11 (default, Jul 24 2020, 11:11:24)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 11.0.3 (clang-1103.0.32.62)] on darwin</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import jupyter</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>아무 문제 없는게 당연하지. 원래 써 왔으니까</p><h2 id="세번째-테스트-환경-clean-virtualenv"><a href="#세번째-테스트-환경-clean-virtualenv" class="headerlink" title="세번째 테스트 환경 - clean virtualenv"></a>세번째 테스트 환경 - clean virtualenv</h2><ol><li><code>pyenv virtualenv 3.6.11 project3</code> 으로 위에 dirty 한 상태의 python 버전으로 project3 virtualenv 생성</li><li><code>pyenv shell project3</code> 지정 </li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python 3.6.11</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> python</span><br><span class="line">/Users/joshua/.pyenv/shims/python</span><br><span class="line"></span><br><span class="line">$ pyenv <span class="built_in">which</span> python</span><br><span class="line">/Users/joshua/.pyenv/versions/project3/bin/python</span><br><span class="line"></span><br><span class="line">$ pip --version</span><br><span class="line">pip 18.1 from /Users/joshua/.pyenv/versions/3.6.11/envs/project3/lib/python3.6/site-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> pip</span><br><span class="line">/Users/joshua/.pyenv/shims/pip</span><br><span class="line"></span><br><span class="line">$ pyenv <span class="built_in">which</span> pip</span><br><span class="line">/Users/joshua/.pyenv/versions/project3/bin/pip</span><br></pre></td></tr></table></figure><p>기본 커맨드는 위와 같이 잘 동작했다.<br>python, pip 등의 커맨드는 기존과 마찬가지로 직접적으로는 shims 를 바라보게 되어있다.<br>하지만 실제 커맨드의 위치(<code>pyenv which</code> 로 확인)는 project3 으로 생성한 virtualenv 에서 사용하게 된다.<br>pip 는 기본으로 python 버전을 설치하든, virtualenv 를 설치하든 기본으로 따라온다.</p><p>기본으로 따라오지 않는 jupyter 갖고 또 실험해 보자</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter</span><br><span class="line">pyenv: jupyter: <span class="built_in">command</span> not found</span><br><span class="line"></span><br><span class="line">The `jupyter<span class="string">&#x27; command exists in these Python versions:</span></span><br><span class="line"><span class="string">  3.6.11</span></span><br><span class="line"><span class="string">  3.6.11/envs/project1</span></span><br><span class="line"><span class="string">  3.6.11/envs/project2</span></span><br><span class="line"><span class="string">  project1</span></span><br><span class="line"><span class="string">  project2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note: See &#x27;</span>pyenv <span class="built_in">help</span> global<span class="string">&#x27; for tips on allowing both</span></span><br><span class="line"><span class="string">      python2 and python3 to be found.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ pyenv whence jupyter</span></span><br><span class="line"><span class="string">3.6.11</span></span><br><span class="line"><span class="string">3.6.11/envs/project1</span></span><br><span class="line"><span class="string">3.6.11/envs/project2</span></span><br><span class="line"><span class="string">project1</span></span><br><span class="line"><span class="string">project2</span></span><br></pre></td></tr></table></figure><p>위와 같이 virtualenv 안에서 밖의 python 의 jupyter 에는 접근이 안된다.<br>import 역시 안되는것으로 보아, virtualenv 는 기본 버전에 뭐가 깔려있든 완전 격리 되었다.</p><h2 id="마지막-테스트-환경-virtualenv-에-패키지-설치"><a href="#마지막-테스트-환경-virtualenv-에-패키지-설치" class="headerlink" title="마지막 테스트 환경 - virtualenv 에 패키지 설치"></a>마지막 테스트 환경 - virtualenv 에 패키지 설치</h2><ol><li>위 <code>project3</code>  에다가 <code>pip install jupyter</code> 로 패키지를 설치</li></ol><p>뭐 당연히 설치 했으니 잘 동작하겠지만, 확인차..</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> jupyter</span><br><span class="line">/Users/joshua/.pyenv/shims/jupyter</span><br><span class="line"></span><br><span class="line">$ pyenv <span class="built_in">which</span> jupyter</span><br><span class="line">/Users/joshua/.pyenv/versions/project3/bin/jupyter</span><br></pre></td></tr></table></figure><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>그렇다면, 각 python 과 virtualenv 마다 필요한게 있으면 각각 설치해줘야 한다는 결론이다.<br>pip 는 그냥 따라오는 기본이라 설치해주지 않아도 되는 거구요.<br>poetry 의 경우에는 버전마다 설치해줘야 되는게 맞고, poetry 자체에 virtualenv 관리 기능이 있어서 virtualenv 는 따로 생성하지 않고 poetry 한테 맡기면 되지 않나~ 하는 생각이다.</p><p>혹시 그렇다면 pyenv 의 관리 외에 설치된 python 에 설치된 것은, 현재 pyenv 로 어떤 version 을 선택하든지,  접근이 가능하지 않을까??<br>(예를 들어 mac 기본 python 이라든가, brew 로 설치한 python 이라든가..)</p><p>이거는 뭐 현재 shell 의 <code>PATH</code> 환경변수를 확인해 보는것으로 알 수 있다.<br>원래 python 에서 실행가능 binary 들은 각 환경의 bin 디렉토리 안에 저장 된다. (<code>pyenv which</code> 명령어로 실제 위치 확인)<br>그리고 <code>env | grep PATH</code> 를 해보면, 현재 <code>PATH</code> 환경 변수를 볼수 있는데, 맨앞에 pyenv 관련 shims 디렉토리들이 지정되어있는것을 확인 할 수 있다.<br>따라서 pyenv 관리 하에 있는 python 버전들은, 모두 이 shims 를 통해서 사용이 되며, pyenv 관리 밖에 있는 python 버전들은 따로 <code>PATH</code> 환경 변수에 지정하든지 해서 사용하면 될듯 하다.<br>하지만.. 더이상의 복잡함은 나의 두뇌에 허용하지 않겠다</p>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/python/">python</category>
      
      <category domain="https://humbledude.github.io/blog/tags/pyenv/">pyenv</category>
      
      
      <comments>https://humbledude.github.io/blog/2021/03/31/pyenv-experiment/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Airflow KubernetesExecutor 차트 업데이트</title>
      <link>https://humbledude.github.io/blog/2020/10/23/airflow-k8s-chart/</link>
      <guid>https://humbledude.github.io/blog/2020/10/23/airflow-k8s-chart/</guid>
      <pubDate>Fri, 23 Oct 2020 08:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번에는 Airflow 를 여러벌 올려야 하는 일이 생겼다.&lt;br&gt;이참에 고친다는 마음으로 helm chart 도 정비해서 다른 사람들한테 공유가 가능한 수준으로 좀 다듬어 졌다.&lt;/p&gt;
&lt;h2 id=&quot;전체-구성도&quot;&gt;&lt;a href=&quot;#전체-구성도</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번에는 Airflow 를 여러벌 올려야 하는 일이 생겼다.<br>이참에 고친다는 마음으로 helm chart 도 정비해서 다른 사람들한테 공유가 가능한 수준으로 좀 다듬어 졌다.</p><h2 id="전체-구성도"><a href="#전체-구성도" class="headerlink" title="전체 구성도"></a>전체 구성도</h2><p>일단 지난번 포스트(<a href="https://humbledude.github.io/blog/2019/07/12/airflow-on-k8s/">https://humbledude.github.io/blog/2019/07/12/airflow-on-k8s/</a>) 의 그림과 조금 다르지만 뭐 같다고 봐도 되겠쥬</p><img src="/blog/2020/10/23/airflow-k8s-chart/20200117_airflow_k8s_(1).png" class="" title="구성도"><p>다른 점은 <code>ConfigMap</code> 으로 Airflow 설정을 한다는 점인데, 아래에 좀더 자세히 설명이 되어있다.</p><p>이전 글에도 설명했지만, 간단히 Airflow + <code>KubernetesExecutor</code> 의 동작 방식을 설명한다면~</p><ul><li>scheduler 는 DAG 내에 정의된 각 task 마다 worker pod 을 만들어 띄운다.</li><li>worker pod 의 init container 는 git-sync 를 통해 dag 를 다운받고, 필요한 task 를 실행한다.</li><li>만약 worker pod 이 실행해야 될 task 가 <code>KubernetesPodOperator</code> 였다면, task 에 정의된 대로 pod 를 하나 더 띄우고, 해당 pod 의 작업이 잘 동작하는지 모니터링 하는 역할을 한다.</li><li>만약 worker pod 이 실행해야 될 task 가 그 외의 Operator 였다면 (예를 들어, <code>PythonOperator</code>), 해당 동작은 worker container 가 직접 실행한다.</li></ul><p>따라서 <code>KubernetesPodOperator</code> 외에 다른 어떤 Operator 들을 실행하려면, 실행 환경을 worker 의 이미지에 다 담아야 한다.<br>예를 들어, 나는 <code>SqoopOperator</code> 를 실행하려고 했는데, 그러려면 worker image 에 sqoop 명령어와, 각종 권한 관련 환경 셋팅을 해야 한다는 것이다.</p><p>그리고 Airflow 가 worker 를 띄우는 명령어는 entrypoint 를 대체하도록 되어있어서 (적어도 현재까지는, 1.10.12) entrypoint 에 환경설정을 하는 스크립트를 넣으려면 약간의 꼼수가 필요했다.<br>이거는 나중에 필요한 사람이 있다면 또 글을 쓰게 될지도 ㅎㅎ<br>(참고 : <a href="https://github.com/apache/airflow/issues/8495">https://github.com/apache/airflow/issues/8495</a>)</p><h2 id="Helm-Chart"><a href="#Helm-Chart" class="headerlink" title="Helm Chart"></a>Helm Chart</h2><p>이번에 chart 를 개발하면서 주로 변경한 점은, <code>ConfigMap</code> 을 통해 Airflow 설정을 관련 Pod 들이 공유 할 수 있도록 한 것이다.<br>Airflow 설정은 초기 chart 에서는 cfg 파일에 정의해서 썼었다.<br>그렇게 하면 그 수많은 Airflow 설정값을 일일이 chart 의 항목으로 옮겨 적어야 되서 좀 고생스러웠는데…<br>Airflow 에서는 환경변수를 통해 설정값을 조절하는 방법도 제공하고 있었다.</p><p>(참조 : <a href="https://airflow.apache.org/docs/stable/howto/set-config.html">https://airflow.apache.org/docs/stable/howto/set-config.html</a>)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> AIRFLOW__&#123;SECTION&#125;__&#123;KEY&#125;=&#123;VALUE&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 포맷으로 설정값을 지정하면 Airflow 의 cfg 파일에 override 해서 설정이 적용된다.</p><p>그리고 Kubernetes 에서는 <code>ConfigMap</code> 의 모든 값을 환경변수로 가져오는 기능이 있다.<br><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables">https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables</a></p><p>따라서, Airflow 의 configuration 정의를 모두 <code>ConfigMap</code> 으로 넣고, webserver, scheduler, worker 가 같은 <code>ConfigMap</code> 을 사용해 환경변수를 설정하면, configuration 을 복붙할수 있다는거다.</p><p>chart 는 아래에 업로드 되어있다.<br><a href="https://github.com/humbledude/airflow_k8s_chart">https://github.com/humbledude/airflow_k8s_chart</a></p><p>많은 사람들에게 공유할 차트로 쓰기에도 아직 좀 부족한데.. 그냥 일단 블로깅 용으로 공유 한다 ㅎㅎ</p><ul><li>helm v2 에서만 테스트 해본점</li><li>ingress 가 없을때 딱히 예외처리가 없는 점</li><li>github 에서 DAG fetch 하는거 외에 딱히 옵션이 없는 점</li></ul><p>등등이 좀 허접한 것이지만<br>참고하실 분이 있다면 쓰라는 의미에서~<br>chart 내의 <code>airflow_config_env</code> 에 Airflow configuration 항목을 집어 넣으면 그게 다 <code>ConfigMap</code> 으로 생성된다.</p><p>직접 코드를 보면 다 이해가 되실 것으로..<br>(직접 짜기가 고생스럽지만, 짜 놓은 차트는 별거 없다는 helm 의 세계..)</p>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/kubernetes/">kubernetes</category>
      
      <category domain="https://humbledude.github.io/blog/tags/airflow/">airflow</category>
      
      
      <comments>https://humbledude.github.io/blog/2020/10/23/airflow-k8s-chart/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>맥 타임머신 백업 속도 빠르게 하기</title>
      <link>https://humbledude.github.io/blog/2020/10/23/mac-backup-speedup/</link>
      <guid>https://humbledude.github.io/blog/2020/10/23/mac-backup-speedup/</guid>
      <pubDate>Fri, 23 Oct 2020 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;맥을 옮기기 위해 처음 백업을 해봤다.&lt;br&gt;더럽게 느리길래 방법을 찾아봤는데..&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://macnews.tistory.com/4280&quot;&gt;https://macnews.tistory.com/4280&lt;/a&gt;&lt;br&gt;여</description>
        
      
      
      
      <content:encoded><![CDATA[<p>맥을 옮기기 위해 처음 백업을 해봤다.<br>더럽게 느리길래 방법을 찾아봤는데..</p><p><a href="https://macnews.tistory.com/4280">https://macnews.tistory.com/4280</a><br>여기서 시키는 대로 low priority 의 throttle 을 변경 했더니~~<br>똑같이 더럽게 느리더라</p><p>그래서 직접 백업프로세스의 우선순위를 높여보기로 했다.<br>아 이 방법은, 맥의 CPU 자원 사용을 더 높이는 거라서 단순히 백업 종료만 기다리는 상황일때만 써보자.<br>다른 작업의 성능에 영향을 줄 수 있으므로~</p><p><code>활성상태보기</code> 에서 백업 담당 프로세스가 뭘까 찾아보니, backupd 인거 같았다.<br>이친구의 PID 는 내꺼에서는 261 이다</p><img src="/blog/2020/10/23/mac-backup-speedup/Untitled.png" class="" title="활성상태보기"><p>사진은 조치 후에 찍어서 CPU 가 80% 사용중이다.<br>조치 전에는 한 10% 썼었나..</p><p>프로세스의 현재 nice 값을 보는 방법은 아래와 같다<br>터미널을 열어서 때려본다</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -fl -C 261</span><br></pre></td></tr></table></figure><p>여기서 <code>261</code> 은 본인의 backupd 의 PID 를 넣자</p><img src="/blog/2020/10/23/mac-backup-speedup/Untitled%201.png" class="" title="ps 결과"><p>참고로 프로세스의 nice 값은 프로세스가 다른 프로세스 친구들에게 얼마나 nice 한지를 설정하는 값이다.<br>다른 친구들에게 nice 한 프로세스는 자꾸 CPU 를 너 먼저 쓰세요~ 하고 양보한다.<br>이 값은 -20 ~ 20 사이로 설정이 가능한데, -20 이 안 nice 한 값이다.</p><p>암튼 이 backupd 프로세스를 완전 이기주의 프로세스로 만들어주자</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo renice -n -20 -p 261</span><br></pre></td></tr></table></figure><p>backupd 는 이제 완전 극악무도한 CPU 탐욕덩어리가 되었다.<br>다시한번 <code>활성상태보기</code> 를 들어가서 CPU 사용률이 올라간것을 확인하자.<br>사진은.. 위에 이미 찍었다.<br>(원체 우선순위가 낮아서 그런지 막 200% 먹고 그러지는 않는군)</p><p>그리고 타임머신 백업의 시간이 단축된것도 확인해보자 ㅎㅎ<br>내 경우엔 15시간에서 5시간으로 줄었네?? (더 줄이고 싶지만 오늘은 그냥 넘어가준다)</p><img src="/blog/2020/10/23/mac-backup-speedup/Untitled%202.png" class="" title="타임머신"><h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><ul><li><a href="https://www.techrepublic.com/article/how-to-adjust-cpu-priority-using-apples-terminal/">https://www.techrepublic.com/article/how-to-adjust-cpu-priority-using-apples-terminal/</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/mac/">mac</category>
      
      
      <comments>https://humbledude.github.io/blog/2020/10/23/mac-backup-speedup/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python 실전 개발 생태계</title>
      <link>https://humbledude.github.io/blog/2019/08/22/python-dev-env/</link>
      <guid>https://humbledude.github.io/blog/2019/08/22/python-dev-env/</guid>
      <pubDate>Thu, 22 Aug 2019 03:53:12 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Java 에는 maven 이 있고, Javascript / node 에는 npm 이 있고, python 에는 pip 가 있는건가? setuptools 가 있는건가? conda??? 뭐지??&lt;/p&gt;
&lt;p&gt;Java 는 배포할때 maven 뷜드 하면 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>Java 에는 maven 이 있고, Javascript / node 에는 npm 이 있고, python 에는 pip 가 있는건가? setuptools 가 있는건가? conda??? 뭐지??</p><p>Java 는 배포할때 maven 뷜드 하면 되고, Javascript 는 그냥 브라우저에서 돌고, python 은 git pull 하면 되는건가?? 뭐지?</p><p>Java 는 dependency 작업을 maven / gradle 로 하면 되고, Javascript 는 npm 하고 package.json 하면 되는데, python 은 어따가 뭘 명시해서 하지? </p><p>Java 는 jdk 깔고 개발하면 되고, Javascript 는 ES6를 할지 Typescript 해서 webpack 을 하든지 하고 python 은 2는 곧 죽는대서 3 쓰면 되는건데 python 3.6.3 깔았는데 3.7.3 에서 왜 에러가 나지??? 시스템 python은 2.x 인데 뭐지??</p><p>대충 내가 아는 다른 언어 개발 생태계와 비교해서 python 을 처음 개발할때부터 느꼈던 코딩 외적인 생태계의 좌절감을 표현해봤다.</p><p>(짧은 레퍼런스의 한계..)</p><p>그동안 겪었던 python 개발 생태계를 정리해서 개인적인 의견으로 best practice 겸 해서 써봅니다. 더 나은 방법이 있으면 공유해 주세요ㅎㅎ</p><p>저는 pc로 맥을 쓰고 있고, 서버로 linux 를 사용하기 땜에 windows 사용자와는 안맞는 말이 있을수 있습니다.</p><h2 id="pyenv-python-설치-버전관리-dependency-격리"><a href="#pyenv-python-설치-버전관리-dependency-격리" class="headerlink" title="pyenv - python 설치 버전관리,  dependency 격리"></a>pyenv - python 설치 버전관리,  dependency 격리</h2><p>자신의 pc 에서 터미널을 켜고 python 을 치면 어떤 버전이 동작하는지 확신 할수 있는가?<br>현재 프로젝트가 어떤 python 버전으로 돌려야 하며, dependency 설치한게 어디에 설치되어있고, 설치된 패키지 중, 이 프로젝트에 최소한으로 필요한 dependency 가 무엇인지 알 수 있는가? (다 알면.. 패쓰..)</p><p>mac 에서는 기본 python 이 2.x 이다. 우분투는 최근? 3.x 로 넘어왔고, 어느 리눅스 배포판은 python 자체가 없다.</p><p>brew 로 python3 를 설치하고, virtualenv 로 프로젝트별 dependency 를 격리해서 개발하고 있다면, 더이상 할게 없어 보인다.<br>하지만 개인적으로는 pyenv 를 통해 이걸 쉽게 하고 있다.</p><p><a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a></p><p>pyenv 를 통해서 python 을 각 버전별로 설치 가능하고, (anaconda 도 python 버전중에 하나로 취급해버림..)<br>pyenv-virtualenv 를 통해서 손쉽게 virtualenv 를 사용할수 있다. (no more venv/bin/activate &amp; deactivate)</p><p>혹 virtualenv 를 모르시는 분은 먼저 virtualenv 가 무언지 검색해보고 옵시다. ㅎㅎ</p><h3 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h3><p>참고1 :  <a href="https://github.com/pyenv/pyenv#installation">https://github.com/pyenv/pyenv#installation</a></p><p>참고2 : <a href="https://github.com/pyenv/pyenv-installer">https://github.com/pyenv/pyenv-installer</a></p><p>아래 커맨드로 설치하자. brew 로 인스톨할경우 잘 안된다는 사람들이 종종 있으니 확실한 curl 로 설치하자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://pyenv.run | bash</span><br></pre></td></tr></table></figure><p>설치하면 아래 내용을 <code>~/.bash_profile</code> (또는 <code>~/.zshrc</code>) 에 추가하라고 나온다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.pyenv/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init -)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv virtualenv-init -)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>shell 이 시작될때 pyenv 를 초기화 하는 코드이다.</p><h3 id="pyenv-사용법"><a href="#pyenv-사용법" class="headerlink" title="pyenv 사용법"></a>pyenv 사용법</h3><h4 id="특정-python-버전-설치"><a href="#특정-python-버전-설치" class="headerlink" title="특정 python 버전 설치"></a>특정 python 버전 설치</h4><p>일단 뭘 설치할 수 있는지 본다. (설치 가능한 list)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install -l</span><br></pre></td></tr></table></figure><p>쭉 나오는 거중에 3.7.2 를 골라서 설치한다고 한다면</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install 3.7.2</span><br></pre></td></tr></table></figure><p>(여기서 가끔 sqlite library 가 어쩌고 하면서 설치가 실패하는 경우가 있다. stackoverflow의 힘을 빌려보자)</p><p>설치 후 내 pc 에 어떤 python 들이 존재하는지 보자</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><p>system 이라고 나온것이 system 에 설치된 기본 python이다.</p><p>그 외에 pyenv 로 설치한 버전이 나오며, brew 등 다른 방법으로 설치한 python 은 나오지 않으니 주의 (pyenv 를 쓰다보면 그놈들을 없애고 싶어진다)</p><h4 id="default-python-지정"><a href="#default-python-지정" class="headerlink" title="default python 지정"></a>default python 지정</h4><p>터미널을 켜고 python 을 실행했을때 기본으로 실행할 python version 을 지정하자</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv global &#123;VERSION&#125;</span><br></pre></td></tr></table></figure><p>shell 을 켜면 기본으로 사용하게 될 python 을 지정한다고 보면 된다.</p><h4 id="특정-폴더-아래에서-특정-version-의-python-을-지정"><a href="#특정-폴더-아래에서-특정-version-의-python-을-지정" class="headerlink" title="특정 폴더 아래에서 특정 version 의 python 을 지정"></a>특정 폴더 아래에서 특정 version 의 python 을 지정</h4><p>터미널에서 어떤 폴더 (프로젝트 폴더)로 진입하면, 거기부터는 자동으로 특정 version 이 동작하게 해보자</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> &#123;VERSION&#125;</span><br></pre></td></tr></table></figure><p>recursive 하게 그 하위 폴더까지도 버전이 적용된다.</p><h4 id="virtualenv-생성-amp-amp-사용"><a href="#virtualenv-생성-amp-amp-사용" class="headerlink" title="virtualenv 생성 &amp;&amp; 사용"></a>virtualenv 생성 &amp;&amp; 사용</h4><p>virtualenv 는 python 의 실행 환경을 격리시켜서 pc 에 설치된 전체 python package 와 격리된 환경에서 python package 관리를 하게 해준다.</p><p>virtualenv 와 pip 를 통해 dependency 관리를 쉽게 할수 있다.</p><p>기존의 virtualenv 는 해당 프로젝트의 폴더 아래에 venv 같은 이름으로 폴더를 생성하고, 수동으로 activate &amp;&amp; deactivate 하면서 썼었다.<br>하지만 pyenv 로 virtualenv 를 생성하면 ~/.pyenv/versions/.. 해당 폴더는 아래 자리를 잡는다. 그리고 activate &amp;&amp; deactivate 는 위에서 설명한 <code>pyenv local</code> 로 자동으로 설정하면 된다.</p><p>일단 한번 생성해보자. <code>3.7.2</code> 기반의 <code>my-project</code> 라는 virtualenv 이다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.7.2 my-project</span><br><span class="line">pyenv virtualenv &#123;VERSION&#125; &#123;ENV_NAME&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>pyenv versions</code> 를 해보면, <code>3.7.2/envs/my-project</code> 와 <code>my-project</code> 항목이 보인다. (두개가 같은거)</p><p>그리고 어떤 프로젝트의 폴더를 들어가면 방금 생성한 my-project virtualenv 가 자동으로 activate 되게 하자</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> my-project</span><br></pre></td></tr></table></figure><p>다른 폴더로 이동하면 자동으로 deactivate 된다.</p><p>그리고 열심히 개발을 하자…</p><h3 id="pyenv-의-실체"><a href="#pyenv-의-실체" class="headerlink" title="pyenv 의 실체"></a>pyenv 의 실체</h3><p>이 놀라운 일을 해주는 pyenv 는 사실 ~/.pyenv 폴더 안에 모든 실행 파일과 참조 library 를 저장하고, 상황에 맞게 심볼릭 링크 / 참조 path 를 조작 해주는 유틸이라고 생각하면 된다.</p><p>자세한건 아래 링크를 읽어보자.</p><p><a href="https://github.com/pyenv/pyenv#how-it-works">https://github.com/pyenv/pyenv#how-it-works</a></p><p>이 정도면 pyenv 에서 필수적인 부분은 다 해봤다.  pyenv 의 나머지 기능은 알아서 탐구해 보자.. ㅎㅎ</p><h2 id="dependency-설치-참조-path-관리"><a href="#dependency-설치-참조-path-관리" class="headerlink" title="dependency 설치, 참조 path 관리"></a>dependency 설치, 참조 path 관리</h2><h3 id="pip-기본"><a href="#pip-기본" class="headerlink" title="pip 기본"></a>pip 기본</h3><p>virtualenv 를 처음 구성하면, 3rd party 모듈이 하나도 설치되어있지 않은 청정 구역이 나타난다. (pip 를 실행하기 위한 최소한의 모듈만 설치된 상태이다.)</p><p>개발을 진행하면서 pip install 로 여러 모듈을 설치하고 아래와 같이 프로젝트에 설치한 모듈의 리스트를 구하자</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># requests 하나 설치해 봅니다.</span></span><br><span class="line">pip install requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># requirements.txt 로 설치된 3rd party 모듈을 내보낸다</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p><code>requirements.txt</code> 를 열어보면, 모듈명과 그 버전이 나열되어있다.</p><p>나중에 이걸 어디가서 똑같이 설치하려명 이렇게 하면 된다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>근데 pip 로 뭘 설치하면 모듈 코드는 어디에 저장이 되는거고, python 은 어떻게 그 참조 위치를 가져오는 건가?</p><h3 id="python-참조관계-기본"><a href="#python-참조관계-기본" class="headerlink" title="python 참조관계 기본"></a>python 참조관계 기본</h3><p>~/.pyenv 하위 폴더를 까보면 거의 모든걸 알수 있다.</p><p>방금 설치한 <code>3.7.2</code> python 과 <code>my-project</code> virtualenv 를 기준으로 돌아다녀보자</p><p>일단 python 3.7.2 상태에서 설치한 모듈은 여기에 모인다.</p><p><code>~/.pyenv/versions/3.7.2/lib/python3.7/site-packages</code></p><p>그리고 <code>my-project</code> virtualenv 상태에서 설치한 모듈은 여기에 모인다.</p><p><code>~/.pyenv/versions/3.7.2/envs/my-project/lib/python3.7/site-packages</code></p><p>그리고 python runtime 에서 참조하는 path 는 이렇게 알 수 있다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br></pre></td></tr></table></figure><p>그러면 사용중인 python 에 따라 위에서 언급한 site-packages 폴더를 참조하는것을 알 수 있다.</p><p>참조 path 를 추가하거나 관리하는 것은 각자 탐구해보자.</p><p>내가 발견한 방법은 아래와 같다.</p><ul><li><code>PYTHONPATH</code> 라는 환경변수에 지정하거나 (여러 path 간 구분자는 <code>PATH</code> 와 동일하게 <code>:</code> 사용),</li><li><code>sys.path</code> 에다가 추가 하거나 (<code>sys.path.append(&#39;path/to/lib&#39;)</code>)</li><li><code>site-packages/xxx.pth</code> 파일에 추가하거나.. (참고) <a href="https://docs.python.org/3.7/library/site.html">https://docs.python.org/3.7/library/site.html</a></li></ul><p>상황에 맞춰 쓰면 될거 같다.</p><h2 id="python-패키징-배포"><a href="#python-패키징-배포" class="headerlink" title="python 패키징, 배포"></a>python 패키징, 배포</h2><p>패키징이라 함은, 개발한 프로젝트를 어떠한 방식으로 묶어서 재사용이 가능하게 하는 일이다.</p><p>라이브러리 모듈을 개발했다면, pip 같은걸로 받아서 쓸수있게 패키징하여 배포하면 되고,</p><p>웹서버를 개발했다면, 적절히 패키징해서 배포 / 실행할수있게 해야겠다.</p><p>물론 개발 상황은 각자 다르고, 각자의 노하우가 있음을 아는 상태에서, 이런 방법도 있다더라 하는 정도로 받아들일 내용을 적어본다.</p><h3 id="pip-패키징-pypi"><a href="#pip-패키징-pypi" class="headerlink" title="pip 패키징 (pypi)"></a>pip 패키징 (pypi)</h3><p>오리지날 공식 가이드는 이걸 참조한다.</p><p><a href="https://packaging.python.org/">https://packaging.python.org/</a></p><p>모듈을 개발했고, 이걸 pip 로 다운받아 쓸수 있게 하려고 한다면, 이 가이드를 따르면 되겠다.</p><p>pypi 는 pip 의 서버라고 생각하면 되겠다.</p><p>가이드를 따라가다보면, README, LICENSE 이런 내용도 나오는데, 그건 그 문서에서 보도록 하고, 구체적인 할일들만 쫓아가 보자.</p><p>모듈 개발은 완료했다고 치고..</p><ol><li><a href="https://pypi.org/">https://pypi.org/</a> 사이트에 가입한다.</li><li>setup.py 파일을 작성한다<ul><li>여기에 모듈 이름이라던지, 이 모듈을 사용하기 위한 dependency 라던지 하는 내용을 기술하게 되어있다.</li><li>이건 setuptools 라는 배포 유틸에서 쓰게 되는데, 배포 유틸들에 대해 자세히 알고싶으면 이걸 누르자 : <a href="https://packaging.python.org/key_projects/">https://packaging.python.org/key_projects/</a></li></ul></li><li>패키징을 위해 setuptools, wheel, twine 을 설치한다. 각자가 뭔지 알고 싶으면 위 링크에 같이 나와 있다.</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --upgrade setuptools, wheel, twine</span><br></pre></td></tr></table></figure><ol start="4"><li>패키징 실시</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure><ol start="5"><li>그러면 dist/ 폴더 아래에 파일이 생성된다.</li><li>이걸 pypi 서버에 배포한다</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">twine upload dist/*</span><br></pre></td></tr></table></figure><ol start="7"><li>아이디 패스워드를 치고 업로드가 된다. pip install xx 로 받을수 있다!!</li></ol><p>가이드에서는 테스트를 위해 twine 으로 업로드할때 test url 을 먼저 써보는걸 장려한다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span><br></pre></td></tr></table></figure><p>한번 해보면 나중엔 아마 실서버에만 올리게 될듯..</p><h3 id="Docker-패키징"><a href="#Docker-패키징" class="headerlink" title="Docker 패키징"></a>Docker 패키징</h3><p>python 으로 앱을 만들었다면 Docker 로도 한번 패키징 해보자.</p><p>Docker 로 패키징을 하면 python 버전관리 문제로부터도 안전해지고, 뭔가 이게 제대로된 프로덕트가 된듯한 기분도 얻을수 있다!</p><h4 id="base-image-고르기"><a href="#base-image-고르기" class="headerlink" title="base image 고르기"></a>base image 고르기</h4><p>특별한 사유가 없다면 python 공식 docker image 중에서 base 를 고르자</p><p><a href="https://hub.docker.com/_/python">https://hub.docker.com/_/python</a></p><p>마치 pyenv 에서 설치가능한 버전리스트를 받은것마냥 각종 버전 + linux 배포판 들이 모여있다.</p><p>예전같았다면 최대한 lite 하다는 alpine 을 추천했겠지만,, docker 를 쓰다보니 용량이 쪼금 더 많더라도 debian 을 고르게 되었다.<br>alpine 은 가끔가다 호환성 이슈가 발생해서..</p><p>일단 뭐 위에서 pyenv 하면서 작성한 3.7.2 my-project 를 돌리기 위해서 같은 버전  + debian 인 <code>3.7-slim-buster</code> 를 사용해본다. (patch 버전따위 무시한다 )</p><h4 id="일단-돌려보기"><a href="#일단-돌려보기" class="headerlink" title="일단 돌려보기"></a>일단 돌려보기</h4><p>dockerfile 로 이미지를 빌드하기 전에, 간단하게 base image 상태로 프로젝트를 돌려볼 수 있다.</p><p>현재 프로젝트 폴더와, virtualenv 에서 설치한 pip 모듈이 포함된 폴더 정도 mount 해서 돌려보자.</p><p>돌려야되는 파일이 main.py 라고 친다면..</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">print(requests.get(<span class="string">&#x27;http://google.com&#x27;</span>).text)</span><br></pre></td></tr></table></figure><p>요렇게 돌린다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v $(<span class="built_in">pwd</span>):/app \</span><br><span class="line">  -v <span class="variable">$PYENV_VIRTUAL_ENV</span>/lib/python3.7/site-packages:/libs \</span><br><span class="line">  -e PYTHONPATH=/libs \</span><br><span class="line">  python:3.7-slim-buster \</span><br><span class="line">  python /app/main.py</span><br></pre></td></tr></table></figure><ul><li>현재 작성한 프로그램은 <code>/app</code> 에 마운트 했다</li><li>pip 로 설치한 모듈은 <code>/libs</code> 에 마운트하고 <code>PYTHONPATH</code> 환경변수로 참조 경로를 잡아줬다</li></ul><p>python 코드에 다른거 추가하다가 c 로 빌드된 모듈이 있다면 위 방법으로 돌지 않는다. (pc 는 맥이고 docker 는 리눅스 이기 때문에..)</p><p>개발 초기에 docker 테스트 등에만 잠깐 사용해볼만한거..</p><p>바로 dockerfile 작성으로 넘어가 보자.</p><h4 id="dockerfile-작성"><a href="#dockerfile-작성" class="headerlink" title="dockerfile 작성"></a>dockerfile 작성</h4><p>도커라면 역시 dockerfile 로 이미지 만들어 돌려야 제맛이다.</p><p>dockerfile 을 돌리기 전에 pip freeze 를 사용해서 requirements.txt 를 생성해두자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>그리고 dockerfile 작성 - 완전 미니멀이다</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-slim-buster</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /app/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> python /app/main.py</span></span><br></pre></td></tr></table></figure><p>빌드하고 돌려보자. 이건 돌아야 한다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build . --tag <span class="built_in">test</span></span><br><span class="line">docker run <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>그리고 이 이미지를 릴리즈 하고, 돌리면 패키징이 완벽..하게 된거다.</p><p>하지만 이제부터 시작하게 되는 일이 아래와 같이 벌어진다.</p><ol><li>docker 를 non-root 유저로 실행하게 하기</li><li>3rd party 모듈에서 필요로 하는 각종 c library 설치 (리눅스 배포판에 따라 yum / apt 등등으로 설치)</li><li>docker volume / environment variable 로 각종 변동사항 제어하기</li><li>빌드 / 배포 / container 제어 등등 devops</li></ol><p>해당 부분은 python 이슈라기 보다는 docker 의 영역일수 있으니, 열심히 사용하면서 내공을 단련해보자.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>개인적으로 java 를 사용하다 python 을 처음 사용하게 되면서 그 편안함에 박수를 치다가</p><p>중구남방 관리안되는 환경 + 버전별로 이어지는 충돌에 좌절을 겪고,</p><p>그래도 편하니까 계속 쓰다보니 python 개발 생태계에 대해 조금 이해가 생겼다고 판단되어 글을 써봤습니다.</p><p>python 매우 편하니까 많이 씁시다.</p>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/python/">python</category>
      
      <category domain="https://humbledude.github.io/blog/tags/pyenv/">pyenv</category>
      
      <category domain="https://humbledude.github.io/blog/tags/docker/">docker</category>
      
      <category domain="https://humbledude.github.io/blog/tags/pip/">pip</category>
      
      
      <comments>https://humbledude.github.io/blog/2019/08/22/python-dev-env/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Kubernetes 위에서 Airflow 사용하기</title>
      <link>https://humbledude.github.io/blog/2019/07/12/airflow-on-k8s/</link>
      <guid>https://humbledude.github.io/blog/2019/07/12/airflow-on-k8s/</guid>
      <pubDate>Thu, 11 Jul 2019 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;회사에서 batch scheduler 로 Airflow 를 사용할 일이 있었다.&lt;br&gt;나는 Kuberentes 를 공부하고자 하는 의도로 겸사겸사 Airflow 를 Kubernetes 위에서 운용하려고 했다.&lt;br&gt;당시 때마침 Airflow 의 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>회사에서 batch scheduler 로 Airflow 를 사용할 일이 있었다.<br>나는 Kuberentes 를 공부하고자 하는 의도로 겸사겸사 Airflow 를 Kubernetes 위에서 운용하려고 했다.<br>당시 때마침 Airflow 의 Kubernetes 지원이 시작되고 있어서 삽질을 시작해 보았다.<br>다행히 구성에 성공하여 약 3개월간 큰 이슈없이 사용하고 있으니 성공이라 해야 하나..</p><p>내가 사용한 버전은 1.10.2 버전이다.</p><h2 id="구성"><a href="#구성" class="headerlink" title="구성"></a>구성</h2><p>공식? 설치 가이드는 여기에 있다.</p><p><a href="https://github.com/apache/airflow/tree/master/scripts/ci/kubernetes">https://github.com/apache/airflow/tree/master/scripts/ci/kubernetes</a></p><p>kube/deploy.sh 를 실행시키면 되는 구조인데, 스크립트를 열어보면 별로 실행시키고 싶지가 않다..<br>보통 kubernetes 배포라면 helm 이라든지 툴이 많은데, 이걸 직접 template 만들고 shell script 로 쓰다니.. ㅠㅠ</p><p>Airflow Helm Chart 는 여기에 있다. 공식 chart 인지는 모르겠지만..</p><p><a href="https://github.com/helm/charts/tree/master/stable/airflow">https://github.com/helm/charts/tree/master/stable/airflow</a></p><p>근데 이건 기존의 Celery 구성을 그대로 Kubernetes 에 올리는 설정이라, 새로 개발된 Kubernetes Executor 를 사용하지 않았다.<br>Kubernetes native 라면 필요할때 executor 가 올라가서 필요한 만큼만의 resource 를 사용해야 하는데, Celery 가 상주해있는 모양은 k8s native 답지 않아 보였다.  이에 따라 Kubernetes native Airflow 의 Helm chart 를 작성하기에 이르렀다.. (삽질의 시작)</p><p>여러 삽질 끝에 Kubernetes native Airflow 를 쓰려면 아래와 같은 구성이 필요함을 깨달았다.</p><ul><li>DB (MySql or Postgresql 등) - 각종 상태 저장</li><li>Airflow Webserver - web ui 를 호스팅한다, <code>airflow webserver</code> 명령어로 실행</li><li>Airflow Scheduler - webserver 등 에서 지시를 받아 실제 job 을 스케쥴링 (실행) 한다, <code>airflow scheduler</code> 명령어로 실행</li><li>dag 를 저장할 storage</li><li>그리고 잘.. 설정된 <code>airflow.cfg</code> 설정파일과 docker image, kubernetes 설정</li><li>보너스로 log 를 저장할 s3 저장소</li></ul><p>대략적인 구성이 아래와 같이 잡힌다.</p><img src="/blog/2019/07/12/airflow-on-k8s/layout.png" class="" title="레이아웃"><ul><li>dag 는 Github 에 저장하고, 필요할때마다 git pull 해온다.<ul><li>airflow pod 안에 git-sync 컨테이너를 두어 주기적으로 git pull 을 하게 하고, 나머지 webserver,  scheduler 에서는 dag 를 read only 로 사용한다.</li></ul></li><li>airflow 가 <code>KubernetesExecutor</code> 를 사용하게 되면, task 마다 별도의 worker pod 를 실행해서 task 를 실행하게 된다.<ul><li>task 가 <code>KubernetesPodOperator</code> 를 사용해서 구성되어있다면, <code>KubernetesExecutor</code> 는 또 pod 를 생성해서 거기서 작업을 실행한다.</li><li>task 가 그외의 Operator 를 사용한다면, <code>KubernetesExecutor</code> pod 안에서 해당 작업 (예를 들어 <code>SimpleHttpOperator</code> 등) 이 실행된다.</li></ul></li><li>airflow 를 포함하는 docker image 는 webserver, scheduler, worker 가 같은 이미지를 사용하게 된다.<ul><li>물론 설정을 하다보면 다 다른 이미지를 쓰게 설정이 가능한 구조이지만.. 다르게 할 필요가 있을까?</li></ul></li><li>log 의 경우, <code>KuberentesExecutor</code> 가 각각 생겼다가 사라지기 때문에 어딘가 별도로 저장하지 않으면 이력 추적이 불가하다. 다행히 Airflow 는 log backend 로 s3 를 지원한다.<ul><li>근데 회사에서는 s3 를 쓰기 어려워서 minio 를 따로 띄웠다. minio 의 정보는 여기서 얻어보자. (<a href="https://min.io/">https://min.io/</a>)</li><li>각각의 <code>KubernetesExecutor</code> 가 직접 s3 에 log 를 저장하는건지, 아니면 scheduler 등을 통해서 저장하는지는 잘 모르겠다.</li></ul></li></ul><p>그러면 실제 설정 파일을 어떻게 했는지 하나씩 소개해본다.</p><h3 id="docker-image"><a href="#docker-image" class="headerlink" title="docker image"></a>docker image</h3><p>현재 (2019-07) 기준 airflow 는 2.x 가 개발중이고, 1.10.x 에는 막바지에 Kubernetes 관련 기능이 구현 되었다.<br>그래서 현재 stable 한 1.10.x 브랜치에서는 docker image 부분이 좀 빈약한데, 그냥 master 브랜치에서 docker image 부분을 퍼와서 써봤다.</p><p><a href="https://github.com/humbledude/airflow/blob/v1-10-stable/Dockerfile">https://github.com/humbledude/airflow/blob/v1-10-stable/Dockerfile</a></p><p>현재의 master branch 의 Dockerfile 과는 좀 거리가 있지만 그때는 심플하니 좋았다<br>그리고 entrypoint.sh 도 어디선가 적당히 가져다 썼다.</p><p><a href="https://github.com/humbledude/airflow/blob/v1-10-stable/scripts/docker/entrypoint.sh">https://github.com/humbledude/airflow/blob/v1-10-stable/scripts/docker/entrypoint.sh</a></p><p>docker image 는 그냥 airflow 전체 dependency 를 설치한 그런 image 이다.</p><h3 id="airflow-cfg"><a href="#airflow-cfg" class="headerlink" title="airflow.cfg"></a>airflow.cfg</h3><p>airflow.cfg 는 회사에서 필요에 의해 개발하다 보니, 전용 설정이 많아서 전체를 그대로 소개하긴 어렵고, kubernetes native 로 쓰기위해 설정한 부분을 소개한다.<br>이 airflow.cfg 는 helm chart 에서 가져다 쓰기 때문에, templating 문법이 좀 있는데, 그러려니 하자</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line"></span><br><span class="line"># executor 를 KubernetesExecutor 로 해야 task 마다 worker pod 를 생성한다</span><br><span class="line">executor &#x3D; KubernetesExecutor</span><br><span class="line"></span><br><span class="line">[kubernetes]</span><br><span class="line"></span><br><span class="line"># worker 가 사용할 image 를 지정하는 부분이다. 각자 만든 이미지를 쓰자. 내꺼는 사설 repo 에 있음.</span><br><span class="line">worker_container_repository &#x3D; &#123;&#123; .Values.image.worker.repo &#125;&#125;</span><br><span class="line">worker_container_tag &#x3D; &#123;&#123; .Values.image.worker.tag &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 처음에 debugging 할때 여기를 False 로 해두면, worker pod 가 종료 된 후에 삭제 되지 않아서 log 등을 참조할 수 있다</span><br><span class="line">delete_worker_pods &#x3D; True</span><br><span class="line"></span><br><span class="line"># airflow.cfg 를 configmap 에 등록하고 그걸 가져다 쓰게 한다. 그러면 각종 airflow pod 에서 가져다 쓰기 쉽다.</span><br><span class="line">airflow_configmap &#x3D; airflow-configmap</span><br><span class="line"></span><br><span class="line"># worker (Kubernetes Executor) 가 뜰때, dag 를 어디서 가져오게 할것인지 골라야 하는데,</span><br><span class="line"># 나는 git 에서 직접 땡겨오라고 했다. nfs 등을 쓸 수 있지만 잘 안되었어서..</span><br><span class="line"># 그 worker 가 쓸 git 정보이다.</span><br><span class="line">git_repo &#x3D; &#123;&#123; .Values.github.repo &#125;&#125;</span><br><span class="line">git_branch &#x3D; &#123;&#123; .Values.github.branch &#125;&#125;</span><br><span class="line">git_user &#x3D; &#123;&#123; .Values.github.username &#125;&#125;</span><br><span class="line">git_password &#x3D; &#123;&#123; .Values.github.token &#125;&#125;</span><br><span class="line">git_sync_dest &#x3D; &#123;&#123; include &quot;github.repo&quot; . &#125;&#125;</span><br><span class="line">git_dags_folder_mount_point &#x3D; &#123;&#123; include &quot;config.dir.dags-repo&quot; . &#125;&#125;</span><br><span class="line">git_subpath &#x3D;</span><br><span class="line"></span><br><span class="line"># worker 가 git 을 땡겨올때 git command 를 따로 image 에 넣지 않고, git-sync 라는 image 를 써서 땡겨온다</span><br><span class="line">git_sync_container_repository &#x3D; k8s.gcr.io&#x2F;git-sync</span><br><span class="line">git_sync_container_tag &#x3D; v3.1.1</span><br><span class="line">git_sync_init_container_name &#x3D; git-sync-clone</span><br></pre></td></tr></table></figure><h3 id="k8s-구성-helm"><a href="#k8s-구성-helm" class="headerlink" title="k8s 구성 (helm)"></a>k8s 구성 (helm)</h3><p>k8s 구성 또한 전용 설정이 많아 그대로 소개하긴 어렵다 ㅜㅜ<br>혹시나 요청이 있다면 정리해볼지도..<br>기본 틀은 여기를 참고했다.</p><p><a href="https://github.com/apache/airflow/tree/v1-10-stable/scripts/ci/kubernetes/kube">https://github.com/apache/airflow/tree/v1-10-stable/scripts/ci/kubernetes/kube</a></p><p>shell 로 직접 구현한 템플레이팅을 거의 그대로 helm 으로 가져다 썼다.</p><h4 id="ClusterRoleBinding"><a href="#ClusterRoleBinding" class="headerlink" title="ClusterRoleBinding"></a>ClusterRoleBinding</h4><ul><li>Airflow pod 에서 각종 다른 pod 를 생성하기 위해 권한이 필요하다.<ul><li><code>cluster-admin</code> 이라는 ClusterRole 에 바인딩 하는데, 이 <code>cluster-admin</code> 은 문서에 의하면 k8s의 super user 란다. 혹시 너무 큰 권한이 부담스럽다면 다른 pod 를 생성할 수 있는 별도의 role 을 구성해야겠다.</li></ul></li></ul><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><ul><li><a href="https://github.com/apache/airflow/blob/b8a03005c374e2e1e96847e8f6d4cb6e9f1364a4/scripts/ci/kubernetes/kube/templates/airflow.template.yaml#L44">원본</a>은 <code>initContainer</code> 에서 <code>tmp/airflow-test-env-init.sh</code> 를 하는 부분이 있는데, 이거는 뭔지 몰라서 지웠다. 아마 <code>airflow initdb</code> 커맨드를 실행할꺼 같은데, 나는 webserver 컨테이너에서 <code>airflow initdb</code> 커맨드를 실행한다.</li><li>나는 <code>initContainer</code> 에서 git 에서 dag 를 한번 땡겨줬다.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initContainers:</span><br><span class="line">  - name: init-git</span><br><span class="line">    image: &#123;&#123; .Values.image.git.repo &#125;&#125;:&#123;&#123; .Values.image.git.tag &#125;&#125;</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: airflow-dags</span><br><span class="line">      mountPath: &#x2F;tmp&#x2F;git</span><br><span class="line">    args:</span><br><span class="line">      - --repo&#x3D;&#123;&#123; template &quot;github.url&quot; . &#125;&#125;</span><br><span class="line">      - -one-time</span><br></pre></td></tr></table></figure></li><li>그 외에는 동일하게 webserver 와 scheduler 의 container 를 띄운다</li></ul><h4 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h4><ul><li><a href="https://github.com/apache/airflow/blob/v1-10-stable/scripts/ci/kubernetes/kube/templates/configmaps.template.yaml">원본</a>은 ConfigMap 에 그냥 airflow.cfg 파일을 통째로 복붙했는데, 나는 별도 파일에서 가져다 쓰도록 했다.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: airflow-configmap</span><br><span class="line">data:</span><br><span class="line">  airflow.cfg: |</span><br><span class="line">&#123;&#123; tpl (.Files.Get &quot;airflow.cfg&quot;) . | indent 4 &#125;&#125;</span><br></pre></td></tr></table></figure></li><li>그 외에 ui 접근을 위한 ingress 와 db 설정을 위한 secret 이 포함되었다</li></ul><p>띄우는게 일이다. 띄우기만 한다면 다들 쓰는건데 동작이야 하지 않겠는가 … 쩜쩜</p><h2 id="사용하다보니"><a href="#사용하다보니" class="headerlink" title="사용하다보니.."></a>사용하다보니..</h2><p>airflow dag 개발이라든지 하는 부분은 다른 블로그에서도 잘 소개하고 있으니, 그냥 사용중에 배웠던 몇몇 이슈를 적어본다.</p><h3 id="dag-저장소-구성"><a href="#dag-저장소-구성" class="headerlink" title="dag 저장소 구성"></a>dag 저장소 구성</h3><p>처음 airflow 를 접했을때 난감했던 부분이, job (dag) 을 정의한 파일을 업로드 하는 기능이 없다는 거 였다.<br>dag 을 저장할 디렉토리 위치를 airflow.cfg 에서 지정하고, airflow 가 거기서 알아서 dag 를 찾아 쓰게 되어있다.<br>내가 맨 처음에 dag 저장소로 사용하려고 했던게 <code>PersistentVolume</code> 이 었는데, 하나의 nfs volume 을 띄워서 거기에 dag 를 sync 하고, webserver, scheduler, worker 에 mount 하려는 의도였다.<br>하지만 사정상 안정적인 <code>ReadWriteMany</code> volume 을 사용할 수 없었고, mount / umount 중 오류가 자주 발생했었다.</p><p>그래서 그냥 pod 하나에 묶인 webserver 와 scheduler 는 하나의 volume 을 공유하게 했고, worker 는 그냥 그때그때 생길때마다 git pull 을 하는 구조로 구성했다.<br>아마 안정적으로 <code>ReadWriteMany</code> volume 을 사용할 수 있는 환경이라면 dag volume 을 하나로 쓸수 있지 않을까 싶다.</p><h3 id="parallelism-vs-dag-concurrncy-vs-max-active-runs"><a href="#parallelism-vs-dag-concurrncy-vs-max-active-runs" class="headerlink" title="parallelism vs dag_concurrncy vs max_active_runs"></a>parallelism vs dag_concurrncy vs max_active_runs</h3><p>k8s cluster 상에서 동시에 돌수 있는 pod 의 숫자를 제어해야 하는 경우가 있다.<br>이때 비슷한 용어가 세개 있는데 뭘까</p><p><a href="https://airflow.apache.org/faq.html">https://airflow.apache.org/faq.html</a></p><ul><li><code>parallelism</code> 은 동시에 돌 수 있는 worker 의 갯수이다. airflow.cfg 에서 설정</li><li><code>max_active_runs</code> 는 동시에 돌수 있는 DagRuns 의 갯수이다. dag 에서 설정</li><li><code>concurrency</code> 는 동시에 돌 수 있는 task instance 의 갯수이다. dag 에서 설정</li></ul><p>여기서, <code>KubernetesExecutor</code> 를 사용한다면 task instance 마다 worker 가 생겨서 돌기 때문에, worker 가 사용하는 리소스도 고려 해야 한다.<br>worker 가 <code>KubernetesPodOperator</code> 를 구동한다면 하나의 pod 가 더 생성되고, 해당 pod 의 리소스 사용은 dag 에서 제한할 수 있는데, worker pod 자체의 리소스 관리 옵션은 따로 없는 듯 하다.<br>따라서 worker 에서 빡센? 작업을 하지 않도록 해야 하고, 특별히 빡센 작업을 하게 된다면 <code>KubernetesPodOperator</code> 로 따로 지정하고 리소스 관리를 하는게 좋겠다.</p><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ul><li>2020-10-19 업데이트 : 그동안의 깨달음을 바탕으로 전체 구조 그림, 글 좀 수정..</li><li>2020-10-23 업데이트 : 차트 세부사항을 업데이트 해서 글 하나 더 썼어요 (<a href="https://humbledude.github.io/blog/2020/10/23/airflow-k8s-chart">여기</a>)</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/kubernetes/">kubernetes</category>
      
      <category domain="https://humbledude.github.io/blog/tags/airflow/">airflow</category>
      
      
      <comments>https://humbledude.github.io/blog/2019/07/12/airflow-on-k8s/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>기초 데이터 분석 방법 - 확률부터 가설검정, 베이지안 추론까지</title>
      <link>https://humbledude.github.io/blog/2019/02/27/basic-data-analysis/</link>
      <guid>https://humbledude.github.io/blog/2019/02/27/basic-data-analysis/</guid>
      <pubDate>Tue, 26 Feb 2019 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제의-시작&quot;&gt;&lt;a href=&quot;#문제의-시작&quot; class=&quot;headerlink&quot; title=&quot;문제의 시작&quot;&gt;&lt;/a&gt;문제의 시작&lt;/h2&gt;&lt;p&gt;회사에서 검색어를 기반으로 유저의 니즈를 추정하는 업무를 맡게 되었다.&lt;br&gt;예를 들어 &lt;em&gt;강</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제의-시작"><a href="#문제의-시작" class="headerlink" title="문제의 시작"></a>문제의 시작</h2><p>회사에서 검색어를 기반으로 유저의 니즈를 추정하는 업무를 맡게 되었다.<br>예를 들어 <em>강남 맛집</em> 이라는 검색어에 대한 유저의 니즈는 <em>강남역 근처의 맛있는 음식점</em> 이다.</p><p>이번에 유저의 니즈를 파악해야 할 검색어는 <em>스키복할인매장</em> 이다.<br>검색어 <em>스키복할인매장</em> 을 입력한 유저들이 찾는 장소가 다음중 어느것 일까?</p><ol><li>스키타러 가다보면 보이는 외곽지역에 있는 창고형 할인 매장 같은 느낌의 장소인지?</li><li>아니면 스키복을 파는 모든 장소인지? (어짜피 다 할인중이니까!!)</li></ol><p>위 문제를 얼렁뚱땅 내 느낌으로 말고 데이터에 의거해 판단해 보기로 했다.</p><ol><li><em>스키복할인매장</em> 을 검색한 유저의 로그를 분석해서 (1) 또는 (2) 로 분류 한다</li><li>그리고 통계적 추론?을 통해 최종 결론을 내린다.</li></ol><p>일단 1번 스텝에서 로그를 분석해서 분류 하는 부분은 하나씩 로그를 열어봐서 유저의 패턴을 찾아야 되는 상황이다.<br>그러면 가지고 있는 로그 중에 몇 개를 샘플링 해서 수동으로 해야겠다.<br>그리고 그 결과를 바탕으로 통계적 추론 도구를 적용해 보면 되겠다는 생각이 들었다.</p><p>이렇게 생각하고 통계적 추론 도구로 덜컥 <em>베이지안 추론</em> 을 집어 들었다.<br><em>베이지안 추론</em>을 집어 들은 이유는 아래 링크에서 <strong>데이터 사이언티스트가 갖추어야 할 스킬</strong>로서 Bayesian inference 라는 단어를 보았기 때문이다.<br><a href="https://brunch.co.kr/@hero4earth/3">https://brunch.co.kr/@hero4earth/3</a><br>(그렇게 하면 안되는 것이었다..)</p><p>그렇게 무식한 나는 베이지안 추론 -&gt; 베이즈 정리 -&gt; 베이즈 이론? -&gt; 베이즈 확률 -&gt; 확률 -&gt; 통계 -&gt; 가설 검정 … 의 늪에 빠져든다. (이해가 안되니 다른걸 참조 참조 참조.. ㅠㅠ)</p><p>나의 무식함을 탓하며 깊은 늪에 빠졌다가 빠져나오면서 순서대로 정리 해본다.<br>늪에서 발견한 이 모든것의 시작점은 <strong>확률</strong> 이다.</p><h2 id="확률"><a href="#확률" class="headerlink" title="확률"></a>확률</h2><p>중고등학교때 배운 확률과 통계 과목을 떠올려 보자.<br>(안 떠오른다. 그냥 상식적으로 생각한다.)</p><p>보통 이렇게 확률이라는 단어를 사용했다.</p><blockquote><p>동전 하나를 던졌을때 앞면이 나올 확률은 1/2 이다.</p></blockquote><p>근데 실제로 동전을 던져보자</p><blockquote><p>동전 하나를 실제로 100번 던졌는데 앞면이 52번 나왔다.</p></blockquote><p>당연한 말인데, 이걸 정확히 뭐라 부르는지를 못해서 베이지안 추론 에서 여기까지 굴러왔다.<br>같은 내용을 관점에 따라 다르게 표현한 것이다.</p><p>엄밀히 말해 동전의 앞면이 나올 확률이 1/2 이라고 할때는 몇가지 가정이 포함된다.</p><ul><li>동전의 가장자리의 면적은 0이다</li><li>동전의 앞, 뒷면의 면적이 같다</li><li>동전을 던질때 공기의 흐름 등 어쩌구 외부적인 요인은 없다.</li></ul><p>이를 바탕으로 확률을 계산하면 ‘이상적인’ 확률이 등장한다.<br>이 1/2 이라는 값을 <strong>수학적 확률</strong> 이라고 한단다.<br>이건 계산상, 즉 이론상이고..</p><p>현실에 있는 동전을 실제로 던져보면 동전은 분명 앞면 또는 뒷면이 나오고, 동전이 세워지기도 한다…<br>한 100번 던지면 실제로 앞면이 52번이 나오는 경우도 있고, 43번 나올수도 있는거다<br>그러면, 100번 던져서 52번 앞면이 나왔으니까 이렇게 말해도 될까?</p><blockquote><p>이 동전을 던져서 앞면이 나올 확률은 52/100 이야</p></blockquote><p>아 여기부터 좀 애매해진다. 상식적으로는 이렇게 말할 수 있다.</p><blockquote><p>(학교에서 배웠다는 말투로) 야.. 그 동전을 무한히 던지다 보면 확률은 1/2 이 될꺼야..</p></blockquote><p>이처럼 현실에서 <em>확률</em>은 어떠한 <em>확정된 결과</em>로 나타나고, 이를 모아서 <em>일련의 데이터</em>로 취급한다.<br>또는 반대로, <em>현실에 있는 다양한 데이터</em>를 수집해서 사건의 <em>확률</em>을 계산 해 내기도 한다.</p><p>그런데, 이렇게 계산한 확률을 가지고, 아직 일어나지 않은 일이 어떻게 될것인지 <strong>예측</strong>해 보는것도 가능하다.<br>예를 들어, 어떤 이상한 동전이 있는데, 아무리 봐도 이건 1/2 로 앞면이 나오지 않을꺼 같이 생긴거다.<br>(휜거 같기도 하고 뭐 그런느낌)<br>그래서 이걸 100번 던져봤더니 앞면이 46번 나왔다.<br>그래서 이런 결론을 내려 봤다.</p><blockquote><p>이 동전을 던져서 앞면이 나올 확률은 1/2 보다 작다.</p></blockquote><p>자, 이 주장을 믿을 수 있을까?<br>100번 던져서 앞면이 46번 나왔다니까 1/2 보다 적은건 맞는데,<br>그렇다고 이 테스트 결과에 의거해 이 동전을 가지고 하는 도박에서 뒷면에 돈을 더 많이 베팅 할 수 있겠느냐 이거다.</p><p>좀 불안해서 100 번을 더 던져서 앞면이 49번 나왔다.<br>그러면 이걸 믿을 수 있는건가?<br>차라리 무한히 던져보면 어떨까? 무한히 던졌더니 48/100 의 확률이 나온다면 전재산을 가지고 뒷면에 계속 베팅하면 결국 돈을 딴다는 거잖니.<br>근데 당장 돈걸어야되는데 언제까지 무한히 던져야 하는건가..<br>얼마나 동전을 더 던지면 되는걸까?</p><p>이 질문에 답을 찾다보니 <strong>통계</strong>가 등장했다.<br>정확히는 <em>Frequentist (빈도주의) 통계</em>의 영역이 등장한거다.</p><h2 id="빈도주의-통계와-가설검정"><a href="#빈도주의-통계와-가설검정" class="headerlink" title="빈도주의 통계와 가설검정"></a>빈도주의 통계와 가설검정</h2><p>빈도주의 통계?<br>나에게는 매우 생소한 단어였다. 빈도주의와 구분되는 단어는 <em>베이지안</em> 이다.<br>뭐 두가지 학파? 가 있다는 것으로 이해 했다…<br>그리고 보통 접할 수 있는 통계는 빈도주의 통계라고 한다..<br>(그치만 요새 머신러닝 때문에 베이지안도 많이 들을 수도 있다.)</p><p>빈도주의와 베이지안 사고방식의 차이는 아래 블로그에서 잘 설명 해 주셨다.<br><a href="https://blog.naver.com/bestian/10095013721">https://blog.naver.com/bestian/10095013721</a></p><p>위 블로그를 참고해서 우리의 이상한 동전에 대해서 빈도주의적인 접근을 해보자.</p><ol><li>(귀무가설) 이 동전도 보통 동전이라면 1/2 확률로 앞면이 나올 것이다.</li><li>(대립가설) 근데 내눈에는 이 동전이 휘어 보여서 1/2 확률로 앞면이 나올거 같지가 않다.</li><li>그럼 실제로 좀 던져본다. 총 100번 중에 앞면이 46번 나왔다.</li><li>그럼 통계 이론에 따라 좀 계산을 해본다. 결과에 따라 동전이 휘었는지 안휘었는지 판단한다.</li></ol><p>그럼 ‘4. 통계이론에 따라 계산’은 어떻게 풀면 될까?<br>기존의 가설 (1. 귀무가설)을 기반으로 확률 분포를 계산하고,<br><strong>내가 가진 데이터</strong>가 이 분포 상에서 <strong>있을만한 일</strong>이면, <strong>기존의 가설이 맞는것</strong>이고,<br><strong>있을만한 일이 아니</strong>라면, <strong>기존의 가설이 틀릴</strong> 수 있다는거다.<br>있을만한 일의 기준은 <em>신뢰수준</em> 이라는 단어를 써서 95%, 99% 등으로 설정하며,<br>주로 뉴스에서 선거철에 듣는, <em>이 여론조사는 95%의 신뢰수준이 어쩌고..</em> 하는 말에서 나오는 그말이다.<br>95% 신뢰 수준이라는 말은, <strong>100번중에 95번은 가설에 맞는 데이터가 나타난다</strong>는 소리란다.<br>신뢰 수준의 정확한 의미는 여기서 한번 보자<br><a href="http://mkseo.pe.kr/stats/?p=763">http://mkseo.pe.kr/stats/?p=763</a></p><p>상당히 혼미한데, 이 어려운 내용은 그림으로 보자.</p><img src="/blog/2019/02/27/basic-data-analysis/NormalDist1.96.png" class="" title="정규분포-95신뢰수준"><p>그림 펌 : <a href="https://en.wikipedia.org/wiki/Statistical_significance">https://en.wikipedia.org/wiki/Statistical_significance</a></p><p>많이 본듯한 정규 분포 그래프에서 가운데 색칠된 부분이 95% 신뢰 구간이다.<br>내가 가진 데이터가 95% 의 영역 안에 들어가는지? 아니면 양쪽끝 5% (양쪽이니까 각 2.5%) 구간에 속하는지 보는거다.<br>그림상 파란부분이 위 설명에 따르면 <strong>있을만한 일</strong> 의 구간이고, 나머지가 <strong>있을만한 일이 아닌</strong> 구간이다.</p><p>아무튼 됐고, 이제 풀어볼까 하는데, 나는 수학은 1도 모르니까 계산으로는 못푼다. 그냥 그림으로만 보자 ㅎㅎ</p><p>동전을 100번 던졌을때 앞면이 몇번 나올지에 대한 그림을 그려본다.<br>동전 상태는 앞, 뒤 두개밖에 없다고 치면 이항분포를 사용해서 그리면 된단다.<br>그림 그리기에 쓴 툴 : <a href="http://onlinestatbook.com/2/calculators/binomial_dist.html">http://onlinestatbook.com/2/calculators/binomial_dist.html</a></p><img src="/blog/2019/02/27/basic-data-analysis/binomial_1.png" class="" title="동전던지기1"><p>이게 무슨 뜻이냐면, 정상 동전은 100번 던져서 46번 이하로 앞면이 나올 확률이 0.2421 이라는 거다.<br>그게 무슨 소리냐면 지금 100번 던져서 46번 앞면 나온게 <strong>95% 신뢰구간 안</strong>에 있는 상황이고, 이건 꽤나 <strong>있을법한 일</strong>이라는거다.<br>그래서 대체 이게 무슨 소리냐며는 <strong>이 동전은 정상같아 보인다</strong>는거다.</p><p>아 그럴리가 없어.. 얼마나 앞면이 안나와야 이게 휜것일까?<br>100번을 더 던졌는데 이번엔 앞면이 39번 나와서, 앞에 케이스랑 합해서 총 200번 중에 85번 정도 앞면이 나왔다고 치고, 그림을 다시 그려본다</p><img src="/blog/2019/02/27/basic-data-analysis/binomial_2.png" class="" title="동전던지기2"><p>그림대로라면 200번 던져서 앞면이 85번 이하로 나올 확률이 0.02 라는거다.<br>위의 95% 신뢰구간 그림에서 <strong>아랫쪽 2.5% 구간</strong>에 우리 데이터가 들어왔다!!<br>다시말해, 지금 데이터로는 <em>이 동전은 1/2 확률로 앞면이 나온다</em>는 가설로는 <strong>잘 안일어나는 일</strong>이 일어났고,<br>그래서 <em>이 동전은 휘었다</em>는 주장을 통계 이론에 의거해 꽤나 신빙성 있게 하게 되었다.</p><h2 id="베이즈-확률론"><a href="#베이즈-확률론" class="headerlink" title="베이즈 확률론"></a>베이즈 확률론</h2><p>가설검정을 했더니 매우 피곤해졌다.<br>하지만 여기서 멈출수가 없는데, 간지나는 <strong>데이터 사이언티스트</strong>가 되기 위해 베이지안 추론을 할줄 알아야 되겠다.<br>동전던지기를 베이지안 추론으로 어떻게든 해결할 줄 알아야 되는게 아닐까..</p><p>베이지안 추론을 검색하고 글을 보다보면 <em>베이지안 xx</em> 라고 자꾸 베이지안 시리즈가 나오는데,<br>위에서 다룬 빈도주의와 좀 다른 개념으로 확률을 접근한다.<br>베이즈 확률론 이라고 불리는 이 확률 개념을 보자. (검색하면 베이지안 확률론 이라고도 나온다)<br><a href="https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%ED%99%95%EB%A5%A0%EB%A1%A0">https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%ED%99%95%EB%A5%A0%EB%A1%A0</a></p><p><em>지식 또는 믿음의 정도를 나타내는 양</em>을 확률로 표현한다는데…  매우 곤란하고 혼란하다.<br>구지 위의 동전 앞면 1/2 확률에 대해 베이지안 스타일로 말해본다면,</p><blockquote><p>나는 이 동전이 1/2 확률로 앞면이 나올꺼라고 믿는 양이 많아…</p></blockquote><p>정도일려나..ㅜㅜ (그냥 헛소리 같다)</p><p>동전가지고 이 소리를 하면 말이 좀 어색하지만, 보통 베이지안을 사용하는 문제의 영역에서는 꽤나 그럴듯한 표현이 된다.</p><blockquote><p>뉴스에서 어떤 병에 걸릴 확률이 1/100 이란다. 조심하래…</p></blockquote><p>위 내용은 빈도주의적 접근을 해서 표본을 구성하고 그중에 몇명이 병에 걸렸는지 세어본 뒤 나온 의미일 수 있다.</p><blockquote><p>100명중에 1 명이 이 병에 걸렸더라. 그니까 병에 걸릴 확률은 1/100 이야. 신뢰수준 95% 에 표본 오차가 어쩌고..</p></blockquote><p>똑똑한 사람들은 가설 검정을 해서 저 확률을 신빙성 있는 주장으로 만들수도 있겠지?<br>(나는 이제 가설검정 못하겠다..ㅠㅠ)</p><p>그럼 좀더 속편하게 베이지안 사고방식으로 말을 해보자 (조금은 덜 배운 베이지안이다)</p><blockquote><p>100명 중에 1명이 이 병에 걸렸더라. 그니까 나는 이 병에 걸릴 확률이 1/100 임에 손모가지를 걸겠어</p></blockquote><p>와 가설 검정을 건너 뛰었다.. 만세!!!<br>근데 그럼 이런 베이지안 사고방식은 어떻게 신빙성을 갖추는건가? 손모가지로?<br>가설검정처럼 똑똑해 보이는 복잡한 과정 없이 그냥 나누기 하나로 퉁쳤는데??</p><p>사실 답으로 제시한 값은 나누기 한번으로 계산한 것과 같지만, 그 안에는 생략한 말들이 있다.<br>생략한 말을 포함해서 조금 더 배운 베이지안 사고방식으로 말을 해보자</p><blockquote><p>답이 1/100 이 아니고 다른 값일 확률도 존재 하지만, 현 시점에서 나는 답이 1/100 일 확률이 제일 큰거 같다</p></blockquote><p>베이지안 확률론에서 내가 제일 혼미했던 부분이 <strong>확률의 확률</strong>을 언급하고 있다는 거였는데,<br>이거는 어떻게 말로 설명하기 어려우니 좀더 글을 읽다 보다보면 이해가 되길 바란다..<br>(나도 수많은 예제를 보고 겨우 정리한 말이 확률의 확률이라는 단어다.. ㅠㅠ)</p><h2 id="베이지안-추론"><a href="#베이지안-추론" class="headerlink" title="베이지안 추론"></a>베이지안 추론</h2><p>아무튼 데이터 사이언티스트 할려면 베이지안 추론을 해야 된다는데. 너무 돌아돌아 왔다.<br>이제 진짜 베이지안 추론이 뭔지 볼수 있다.<br><a href="https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%EC%B6%94%EB%A1%A0">https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%EC%B6%94%EB%A1%A0</a></p><p><em>추론 대상의 사전 확률과 추가적인 정보를 통해 해당 대상의 사후 확률을 추론하는 방법</em> 이라는데.. ㅠㅠ<br>수많은 글을 섭렵한뒤, 나는 이렇게 생각하기로 했다.</p><ul><li>추론 대상 = 내가 구하고 싶은 사건의 확률</li><li>사전 확률 = 기존에 갖고 있는 데이터로 구한 확률 (또는 데이터가 없다면 그냥 그럴듯한걸로 내세운 확률)</li><li>추가적인 정보 = 이제 새로 구한 데이터</li><li>사후 확률 = 기존 데이터 + 새로 구한 데이터 까지 합해서 구한 확률</li></ul><p>또 다른 말로 표현해보면,<br>베이지안 추론은 <em>현 시점 (현재 내가 가진 데이터 상황)에서의 답</em>을 말하고,<br>데이터가 추가되면 그 데이터에 맞게 확률을 다시 계산함으로써 <em>결론을 갱신</em>해 나간다.<br>데이터가 추가될 때마다 결론이 갱신되고, 문제에 어떠한 확률적 경향이 있다면 점점 그 답에 가까워질 것이다.</p><p>여기서 데이터 추가, 결론 갱신 이라는 속성이 매우 머신러닝 같지 않은가?<br>(그래서 베이지안 검색하다보면 머신러닝이 딸려나오나보다)</p><p>말이 점점 길어지면서  더 혼미하니까, 예제를 보자.</p><blockquote><p>처음에는 100명중에 1명의 환자를 발견했는데, 추가로 100명을 더 검사했더니 3명의 환자가 더 발견 되었다.</p></blockquote><p>일단그림으로 그려보자.<br>참고 : <a href="https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/">https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/</a><br>그림 그리기 툴: <a href="https://homepage.stat.uiowa.edu/~mbognar/applets/beta.html">https://homepage.stat.uiowa.edu/~mbognar/applets/beta.html</a></p><p>위 참고 블로그에 따르면 요건 베타 분포로 그리란다.<br>처음 조사에서 100 명중에, 1명은 감염, 99 명은 비감염이다.</p><img src="/blog/2019/02/27/basic-data-analysis/beta_1.png" class="" title="감염자1"><p>이 그림에 따르면, 그래프가 x 축이 0.01 부분에서 가장 높은데,<br>이게 감염율이 0.01 일 확률 (y축) 이 제일 크다 (확률의 확률..) 라는 의미란다.<br>x 축이 0.01 이 아닌 부분에도 확률이 있음을 확인하자.<br>그치만 그냥 이걸 나같이 덜 배운 사람은 편하게 이렇게 말한다.</p><blockquote><p>이 병에 걸릴 확률은 1% 야..</p></blockquote><p>그러면 추가 검사한 내용까지 포함 해보자.<br>이제 200명 중에, 4명은 감염, 196명은 비감염이다</p><img src="/blog/2019/02/27/basic-data-analysis/beta_2.png" class="" title="감염자2"><p>이제 데이터가 업데이트 되고, x축이 0.02 부분이 제일 높다.<br>이건 이렇게 편하게 말한다.</p><blockquote><p>이 병에 걸릴 확률은 이제 2% 야..</p></blockquote><p>다시 혼미하게 말해 보자.</p><blockquote><p>“이 병에 걸릴 확률은 2%” 라는 확률이 제일 커.. (혼미)</p></blockquote><p>그러나..</p><p>열심히 공부해서 말만 혼미하게 했지, 결국 4/200 계산했다..<br>다음에 더 복잡한 문제가 나왔을때 쓸 일이 있겠지.. ㅠㅠ<br>(하지만 더 복잡한 문제가 나오면 손도 못댄다고 하더라)</p><h2 id="다시-문제로-돌아가서"><a href="#다시-문제로-돌아가서" class="headerlink" title="다시 문제로 돌아가서.."></a>다시 문제로 돌아가서..</h2><p>‘스키복할인매장’ 검색어를 입력한 사람은 대체 무슨 생각이었을까?<br>이게 처음의 문제였다.</p><p>베이지안 추론의 마지막 단락에 의거하여 내린 결론은,<br>그냥 로그 분석해서 그중에 몇개가 창고형 할인매장의 니즈를 갖추었는지 세어보고, 나누기 하면 끝이라는거다…<br>그러면 대략 이런 말을 하게 될것이다.</p><blockquote><p>“스키복할인매장 검색어를 입력한 사람이 창고형 할인 매장을 찾고 있었을 확률이 xx%” 라는 확률이 제일 커.. (혼미)</p></blockquote><p>로그 분석을 자동화 하는데 시간을 쓰는게 낫겠다.. ㅠㅠㅠㅠ<br>(왠지 여기도 머신러닝 -&gt; 베이지안 xx 의 혼미한 구간이 나타날꺼 같다는…)</p><h2 id="그-외-삽질"><a href="#그-외-삽질" class="headerlink" title="그 외 삽질"></a>그 외 삽질</h2><p>베이지안 추론과 베이지안 정리는 공식은 비슷하게 생겼지만, 풀고자 하는 문제의 도메인이 많이 다르다<br>둘을 같이 공부하다보면 매우 혼미해진다</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><h3 id="확률-개념-잡기"><a href="#확률-개념-잡기" class="headerlink" title="확률 개념 잡기"></a>확률 개념 잡기</h3><p>확률론 기초 <a href="https://ratsgo.github.io/statistics/2017/09/21/prob/">https://ratsgo.github.io/statistics/2017/09/21/prob/</a><br>빈도주의적 접근과 베이지안 접근 <a href="https://blog.naver.com/bestian/10095013721">https://blog.naver.com/bestian/10095013721</a></p><h3 id="빈도주의-통계"><a href="#빈도주의-통계" class="headerlink" title="빈도주의 통계"></a>빈도주의 통계</h3><p>오차범위? 신뢰수준? <a href="http://www.pagi.co.id/bbs/board.php?bo_table=economy&amp;wr_id=7279">http://www.pagi.co.id/bbs/board.php?bo_table=economy&amp;wr_id=7279</a><br>가설 검정 한번에 정리하기 <a href="https://kkokkilkon.tistory.com/36">https://kkokkilkon.tistory.com/36</a></p><h3 id="베이지안-통계"><a href="#베이지안-통계" class="headerlink" title="베이지안 통계"></a>베이지안 통계</h3><p>베이지안 통계 첫걸음<br> <a href="https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EC%B2%AB%EA%B1%B8%EC%9D%8C-7e7e1a5f5adc">https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EC%B2%AB%EA%B1%B8%EC%9D%8C-7e7e1a5f5adc</a><br>베이지안 통계 둘째걸음<br><a href="https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EB%91%98%EC%A7%B8-%EA%B1%B8%EC%9D%8C-b486aa23d68b">https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EB%91%98%EC%A7%B8-%EA%B1%B8%EC%9D%8C-b486aa23d68b</a><br>베이지안 추론<br> <a href="https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/">https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/</a></p><h3 id="그래프-그리기-참고"><a href="#그래프-그리기-참고" class="headerlink" title="그래프 그리기 참고"></a>그래프 그리기 참고</h3><p>그래프 그려주는 사이트 모음<br> <a href="https://easy7.tistory.com/17">https://easy7.tistory.com/17</a></p>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D/">데이터 분석</category>
      
      <category domain="https://humbledude.github.io/blog/tags/%ED%99%95%EB%A5%A0%EA%B3%BC-%ED%86%B5%EA%B3%84/">확률과 통계</category>
      
      <category domain="https://humbledude.github.io/blog/tags/%EB%B2%A0%EC%9D%B4%EC%A7%80%EC%95%88-%EC%B6%94%EB%A1%A0/">베이지안 추론</category>
      
      <category domain="https://humbledude.github.io/blog/tags/%EB%B2%A0%EC%9D%B4%EC%A6%88-%ED%99%95%EB%A5%A0%EB%A1%A0/">베이즈 확률론</category>
      
      <category domain="https://humbledude.github.io/blog/tags/%EA%B0%80%EC%84%A4%EA%B2%80%EC%A0%95/">가설검정</category>
      
      
      <comments>https://humbledude.github.io/blog/2019/02/27/basic-data-analysis/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 3 - CPU 동작 원리</title>
      <link>https://humbledude.github.io/blog/2018/12/10/csforhuman-3/</link>
      <guid>https://humbledude.github.io/blog/2018/12/10/csforhuman-3/</guid>
      <pubDate>Mon, 10 Dec 2018 14:34:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이제 슬슬 컴퓨터가 어떻게 동작하는지 보자.&lt;/p&gt;
&lt;p&gt;컴퓨터를 분해하면 초록색 기판에 뭐가 덕지덕지 붙어있다.&lt;br&gt;그 중에 뭐 하나 빼고 전원 버튼을 눌러보자.&lt;br&gt;컴퓨터가 동작을 할수도 있고 안할수도 있다. ㄷㄷ&lt;/p&gt;
&lt;p&gt;이 부품중에</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이제 슬슬 컴퓨터가 어떻게 동작하는지 보자.</p><p>컴퓨터를 분해하면 초록색 기판에 뭐가 덕지덕지 붙어있다.<br>그 중에 뭐 하나 빼고 전원 버튼을 눌러보자.<br>컴퓨터가 동작을 할수도 있고 안할수도 있다. ㄷㄷ</p><p>이 부품중에 뺐을때 반드시 동작을 안하는 몇가지 부품이 있는데, 그중에 하나가 CPU 이다.<br>(몇 개는 빼도 동작한다!!)<br>우리 독자님은 CPU 는 대충 컴퓨터의 두뇌라고 불린다고는 알고 있기를 바란다.</p><p>CPU 는 보통 컴퓨터에서 이렇게 생긴걸로 보인다.</p><img src="/blog/2018/12/10/csforhuman-3/cooler.jpg" class="" title="쿨러 그림"><p>근데 실은 이건 쿨러라고 에어컨 같은 놈이고, 그 밑에 이런 놈이 있다.</p><img src="/blog/2018/12/10/csforhuman-3/cpu.jpg" class="" title="CPU 그림"><p>이놈을 뭐 빼볼 일은 별로 없겠지만 이걸 빼서 뒤집으면 이렇게 생겼다.</p><img src="/blog/2018/12/10/csforhuman-3/cpu_bottom.jpg" class="" title="CPU 뒤집은 그림"><p>뭐가 쩜쩜이 많이 있는데 저게 뭘까?</p><p>우리가 알고있는 애벌레 전자칩에 있는 다리가 저렇게 된거다.<br>CPU 는 다리가 너무 많이 필요해서 저렇게 쩜쩜이로 만든거다.<br>이것만 봐도 CPU 는 너무 복잡한 물건이라는걸 알수 있다.</p><p>CPU 는 뭘하는걸까?<br>CPU 는 복잡하니까 쉽게 생각해보자.</p><p>라면을 끓여 먹어보자.</p><p>라면을 끓이는 방법은 대충 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 냄비에 물을 담는다.</span><br><span class="line">2. 냄비를 가스렌지에 올린다</span><br><span class="line">3. 가스렌지를 켠다.</span><br><span class="line">4. 물이 끓으면 스프를 넣는다.</span><br><span class="line">5. 면을 넣는다.</span><br><span class="line">6. 면이 다 익으면 불을끈다.</span><br><span class="line">7. 냄비를 가져가서 맛있게 냠냠</span><br></pre></td></tr></table></figure><p>(면이 먼저다 스프가 먼저다는 중요한 문제이지만 이 글에서는 일단 그렇다 치고 넘어가자)</p><p>CPU 같은 친구들에게 라면을 끓이게 할려면 아래와 같이 한다.<br>일단 각 행동에 숫자를 붙인다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001 &#x3D; 냄비에 물을 담는다.</span><br><span class="line">002 &#x3D; 냄비를 가스렌지에 올린다.</span><br><span class="line">003 &#x3D; 냄비를 식탁으로 가져간다.</span><br><span class="line">010 &#x3D; 가스렌지를 켠다</span><br><span class="line">011 &#x3D; 가스렌지를 끈다.</span><br><span class="line">020 &#x3D; 스프를 넣는다.</span><br><span class="line">021 &#x3D; 면을 넣는다</span><br><span class="line">031 &#x3D; 물이 끓는지 확인한다.</span><br><span class="line">032 &#x3D; 면이 익었는지 확인한다.</span><br></pre></td></tr></table></figure><p>그리고 이 행동을 어떤 순서로 해야 되는지 종이에 숫자만 적어준다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001</span><br><span class="line">002</span><br><span class="line">010</span><br><span class="line">031</span><br><span class="line">020</span><br><span class="line">021</span><br><span class="line">032</span><br><span class="line">003</span><br><span class="line">011</span><br></pre></td></tr></table></figure><p>이걸 다시 위의 한글로 순서대로 써보면 이렇게 된다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001 &#x3D; 냄비에 물을 담는다.</span><br><span class="line">002 &#x3D; 냄비를 가스렌지에 올린다.</span><br><span class="line">010 &#x3D; 가스렌지를 켠다</span><br><span class="line">031 &#x3D; 물이 끓는지 확인한다.</span><br><span class="line">020 &#x3D; 스프를 넣는다.</span><br><span class="line">021 &#x3D; 면을 넣는다</span><br><span class="line">032 &#x3D; 면이 익었는지 확인한다.</span><br><span class="line">003 &#x3D; 냄비를 식탁으로 가져간다.</span><br><span class="line">011 &#x3D; 가스렌지를 끈다.</span><br></pre></td></tr></table></figure><p>뭐 얼추 맞는 순서다.<br>이 CPU 같은 친구는 종이를 보고 시키는 대로 해서 라면을 끓인다.<br>재밌는건, CPU 는 스스로 판단하지 않고, 오로지 시키는 대로만 한다는거다.</p><p>우리 집에 있는 컴퓨터에 들어있는 CPU 도 하는짓이 이 라면 끓이는 방법과 크게 다르지는 않다.<br>뭔가 숫자를 주면 그 숫자에 맞는 행동을 하는거다.<br>그게 CPU 가 하는 일이다.<br>물론 숫자가 매우 복잡하다…ㄷㄷ</p><p>CPU 는 이렇게 숫자와 그 숫자에 따라 해야 될일을 외우고 있는 칩이다.<br>그리고 누군가 CPU 에게 숫자의 순서들이 적힌 종이를 주면 CPU 는 그대로 움직인다.<br>대신 매우 빠르고 정확하다.</p><p>그럼 누가 CPU 한테 종이를 주는건지는 다음 글에서 알아보자.</p><blockquote><p>연관 용어 : instruction set</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%B4%ED%95%B4/">컴퓨터의 이해</category>
      
      <category domain="https://humbledude.github.io/blog/tags/instruction-set/">instruction set</category>
      
      
      <comments>https://humbledude.github.io/blog/2018/12/10/csforhuman-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Kubernetes 에서 Spark 돌려보기</title>
      <link>https://humbledude.github.io/blog/2018/12/01/spark-on-kube/</link>
      <guid>https://humbledude.github.io/blog/2018/12/01/spark-on-kube/</guid>
      <pubDate>Sat, 01 Dec 2018 13:48:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;쿠버네티스에서 스파크를 돌려볼까 한다.&lt;br&gt;kubernetes 는 좀 할줄 아는 사람, spark 완전 초보를 대상으로 글을 썼다.&lt;br&gt;내가 오늘 처음 Spark 를 돌려봤기에..&lt;br&gt;모든 bash command 는 spark 설치 루트 디</description>
        
      
      
      
      <content:encoded><![CDATA[<p>쿠버네티스에서 스파크를 돌려볼까 한다.<br>kubernetes 는 좀 할줄 아는 사람, spark 완전 초보를 대상으로 글을 썼다.<br>내가 오늘 처음 Spark 를 돌려봤기에..<br>모든 bash command 는 spark 설치 루트 디렉토리 기준이다.</p><h2 id="환경"><a href="#환경" class="headerlink" title="환경"></a>환경</h2><p>로컬 : Mac, mojave 10.14<br>Kubernetes : 1.9, RBAC enabled<br>Spark : 2.4.0</p><h2 id="일단-로컬-mac-에서-standalone-으로-돌려보기"><a href="#일단-로컬-mac-에서-standalone-으로-돌려보기" class="headerlink" title="일단 로컬 mac 에서 standalone 으로 돌려보기"></a>일단 로컬 mac 에서 standalone 으로 돌려보기</h2><h3 id="mac-에-설치하기"><a href="#mac-에-설치하기" class="headerlink" title="mac 에 설치하기"></a>mac 에 설치하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install apache-spark</span><br></pre></td></tr></table></figure><p>로 깔아도 되지만.. 이렇게 설치하면 테스트해볼 example 이 없다..<br>그래서 그냥 <a href="https://spark.apache.org/downloads.html">다운로드 페이지</a>에서 tar 받아서 압축 푼다.</p><h3 id="mac-에서-spark-예제-돌려보기"><a href="#mac-에서-spark-예제-돌려보기" class="headerlink" title="mac 에서 spark 예제 돌려보기"></a>mac 에서 spark 예제 돌려보기</h3><p>제일 간단하게 python pi 예제  돌려보는 커맨드<br>(결과가 log 사이에 섞여서 나온다.)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;spark-submit examples&#x2F;src&#x2F;main&#x2F;python&#x2F;pi.py</span><br></pre></td></tr></table></figure><p>워드카운트 예제도 돌려본다.<br>(arguments를 받을 수 있다는걸 배웠다.)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;spark-submit examples&#x2F;src&#x2F;main&#x2F;python&#x2F;wordcount.py README.md</span><br></pre></td></tr></table></figure><h2 id="이제-kubernetes에서-클러스터로-돌려보기"><a href="#이제-kubernetes에서-클러스터로-돌려보기" class="headerlink" title="이제 kubernetes에서 클러스터로 돌려보기"></a>이제 kubernetes에서 클러스터로 돌려보기</h2><h3 id="그전에-이미지-빌드"><a href="#그전에-이미지-빌드" class="headerlink" title="그전에 이미지 빌드"></a>그전에 이미지 빌드</h3><p>kubernetes에서 spark 를 돌리려면, pods 를 생성할 base docker image 가 필요하다.<br>요렇게 해서 한번 만들어 보자</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;docker-image-tool.sh build</span><br></pre></td></tr></table></figure><p><code>docker images</code>로 확인해보면 이미지가 세개 만들어져 있다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY     TAG                  IMAGE ID            CREATED             SIZE</span><br><span class="line">spark-r        latest               76831d4bc63c        5 days ago          764MB</span><br><span class="line">spark-py       latest               ec2d882c5f8a        5 days ago          438MB</span><br><span class="line">spark          latest               90cf7bdaee92        5 days ago          348MB</span><br></pre></td></tr></table></figure><p>아 이미지가 개발 언어마다 다른가보다..<br>참고로 이 이미지를 만드는 <code>dockerfile</code> 은 여기 있다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubernetes&#x2F;dockerfiles&#x2F;spark</span><br></pre></td></tr></table></figure><p>(spark-r 과 spark-py 용 dockerfile 은  그 아래 <code>bindings</code> 를 뒤져보면 각각 dockerfile 이 나온다.)</p><p>docker image 안에 필요한 파일을 다 넣고 이미지를 만들어야 한다.<br>application 도 이미지 안에 넣어두어야 하는데, 로컬에 있는 application 을 kubernetes 로 바로 전송하면서 실행하는 모드는 아직 없다고 한다.<br>(네트워크에서 접근 가능한  링크로 제공하는건 괜찮다고 한다.)</p><p>이렇게 만든 이미지는 kubernetes 가 pods 를 만들때 끌어다 쓸 수 있는 docker registry 에 올려 두자<br>나는 docker 커맨드를 사용했지만, docker-image-tool.sh 의 옵션으로도 제공한다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;docker-image-tool.sh -r docker.io&#x2F;myrepo -t v2.3.0 build</span><br><span class="line">bin&#x2F;docker-image-tool.sh -r docker.io&#x2F;myrepo -t v2.3.0 push</span><br></pre></td></tr></table></figure><p>-r 옵션으로 registry 를 지정하고<br>-t 옵션으로 tag 를 지정하자</p><h3 id="RBAC-설정"><a href="#RBAC-설정" class="headerlink" title="RBAC 설정"></a>RBAC 설정</h3><p>알고보니 내가 쓰는 클러스터는 RBAC 가 enable 되어있었다.<br>일단 spark-submit 을 kubernetes 에다가 때리면, driver 라는 pod 가 생기고, 이놈이 다른 executor pods 를 만든다.</p><img src="https://spark.apache.org/docs/latest/img/k8s-cluster-mode.png" class="" title="출처 : 공식 홈페이지"><p>그런데 pod 주제에 다른 pods 를 만들려면 권한이 있어야 하는거다.<br>그래서 권한 셋팅을 한다.<br>(나는 어쩌다보니 namespace 까지 설정 해버렸다.. namespace 는 default 로 해도 되겠더라)</p><h4 id="namespace-yml"><a href="#namespace-yml" class="headerlink" title="namespace.yml"></a>namespace.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Namespace</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: spark</span><br><span class="line">  labels:</span><br><span class="line">    name: spark</span><br></pre></td></tr></table></figure><h4 id="serviceaccount-yml"><a href="#serviceaccount-yml" class="headerlink" title="serviceaccount.yml"></a>serviceaccount.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ServiceAccount</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: spark</span><br><span class="line">  name: spark</span><br></pre></td></tr></table></figure><h4 id="role-yml"><a href="#role-yml" class="headerlink" title="role.yml"></a>role.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: spark</span><br><span class="line">  name: spark-role</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;pods&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;]</span><br></pre></td></tr></table></figure><h4 id="rolebinding-yml"><a href="#rolebinding-yml" class="headerlink" title="rolebinding.yml"></a>rolebinding.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: spark-rolebinding</span><br><span class="line">  namespace: spark</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: spark</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: spark-role</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><p>파일이 많아서 혼미한데, 이게 뭔소리냐면,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spark 네임스페이스 아래에서 이 모든 일이 일어날 것인데,</span><br><span class="line">spark-rolebinding 에 적혀있기를,</span><br><span class="line">spark 서비스 어카운트 님은</span><br><span class="line"> spark-role 롤을 가질 것이다.</span><br></pre></td></tr></table></figure><h2 id="진짜로-예제-돌리기"><a href="#진짜로-예제-돌리기" class="headerlink" title="진짜로 예제 돌리기"></a>진짜로 예제 돌리기</h2><p>이렇게 셋팅을 하고 아래와 같이 예제를 돌린다</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;spark-submit \</span><br><span class="line">-—master k8s:&#x2F;&#x2F;https:&#x2F;&#x2F;KUBERNETES_MASTER_NODE:PORT \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name spark-pi \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--conf spark.executor.instances&#x3D;2 \</span><br><span class="line">—-conf spark.kubernetes.namespace&#x3D;spark \</span><br><span class="line">—-conf spark.kubernetes.authenticate.driver.serviceAccountName&#x3D;spark \</span><br><span class="line">--conf spark.kubernetes.container.image&#x3D;humbledude&#x2F;spark \</span><br><span class="line">local:&#x2F;&#x2F;&#x2F;opt&#x2F;spark&#x2F;examples&#x2F;jars&#x2F;spark-examples_2.11-2.4.0.jar</span><br></pre></td></tr></table></figure><p>local:// 부터는 docker image 안에서 application 의 위치를 지정해준다.<br>내 pc에 있는걸 바로 돌리는건 아직 안된다고 한다.</p><p>옵션은 이렇게 동작한다.</p><ul><li><code>--master</code> : 쿠버네티스 마스터 노드, k8s://로 시작하면 된다. (kubectl cluster-info 로 알수 있다)</li><li><code>--deploy-mode</code> : cluster / client 모드가 있다.<ul><li>cluster 모드는 쿠버네티스 상에 application 을 돌리기 위해 driver 와 executor  를 다 알아서 생성하고 정리하는 모드이다.</li><li>client 모드는 spark-shell 이나 notebook 처럼 interactive 모드로 작업하기 위한 모드라 한다. (별도 옵션으로 server / port 를 지정해 줘야 한다)</li></ul></li><li><code>--name</code> : 이름이다. pod 이름이 이거 기반으로 생성된다.</li><li><code>—-class</code> : jar 파일 내 실행 클래스</li><li><code>—-conf spark.executor.instances</code> : executor 갯수이다. 쿠버네티스 클러스터에서 감당 못하는 숫자를 넣으면 어떻게 되는지 아직 안해봤다.</li><li><code>—-conf spark.kubernetes.authenticate.driver.serviceAccountName</code> : 위에서 만든 serveice account 를 넣는다. 이 account 가 적절한 권한이 있어야 한다.</li><li><code>—-conf spark.kubernetes.namespace</code> : 위에서 만든 namespace 를 넣는다. namespace 를 따로 안만들고 default 로 했으면, 이 옵션이 필요가 없다.</li><li><code>—-conf spark.kubernetes.container.image</code> : 위에서 만든 docker image 위치를 넣는다. 쿠버네티스에서 접근 가능한 위치에 image 가 있어야겠지?</li></ul><p>python 도 돌려보자</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spark-submit \</span><br><span class="line">-—master k8s:&#x2F;&#x2F;https:&#x2F;&#x2F;KUBERNETES_MASTER_NODE:PORT \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name spark-py-pi \</span><br><span class="line">--conf spark.executor.instances&#x3D;2</span><br><span class="line">--conf spark.kubernetes.namespace&#x3D;spark</span><br><span class="line">--conf spark.kubernetes.authenticate.driver.serviceAccountName&#x3D;spark \</span><br><span class="line">--conf spark.kubernetes.container.image&#x3D;humbledude&#x2F;spark-py \</span><br><span class="line">local:&#x2F;&#x2F;&#x2F;opt&#x2F;spark&#x2F;examples&#x2F;src&#x2F;main&#x2F;python&#x2F;pi.py</span><br></pre></td></tr></table></figure><p>별거 없고, image 만 교체하고, <code>—-class</code>  만 뺐다.<br>잘돈다.</p><p>결과는 <code>kubectl logs PODS</code> 으로 본다.<br>(example 이니까 결과가 로그에 나오는걸로..)</p><h2 id="기타-삽질들"><a href="#기타-삽질들" class="headerlink" title="기타 삽질들.."></a>기타 삽질들..</h2><h3 id="삽질-1"><a href="#삽질-1" class="headerlink" title="삽질 1"></a>삽질 1</h3><p>얼마전엔 brew 로 spark 인스톨 했더니 <code>2.3.2</code> 가 깔리고,<br>image build 는 홈페이지에 받은 <code>2.4.0</code> tar 파일 압축푼 디렉토리에서 했더니 application 을 돌릴수가 없었다.<br><code>2.3.2</code>/ <code>2.4.0</code> 두 버전간 호환이 안되니, 잘 맞춰서 하자</p><h3 id="삽질-2"><a href="#삽질-2" class="headerlink" title="삽질 2"></a>삽질 2</h3><p><code>2.3.2</code> 에서 python 돌릴라고 했더니 쿠버네티스에서는 python 안된다고 떴었다.<br><code>2.4.0</code> 에서는 잘 돌았다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><h3 id="공식-문서"><a href="#공식-문서" class="headerlink" title="공식 문서"></a>공식 문서</h3><p><a href="https://spark.apache.org/docs/latest/running-on-kubernetes.html">https://spark.apache.org/docs/latest/running-on-kubernetes.html</a></p><h3 id="2-4-0-what’s-new-블로그"><a href="#2-4-0-what’s-new-블로그" class="headerlink" title="2.4.0 what’s new 블로그"></a>2.4.0 what’s new 블로그</h3><p><a href="https://databricks.com/blog/2018/09/26/whats-new-for-apache-spark-on-kubernetes-in-the-upcoming-apache-spark-2-4-release.html">https://databricks.com/blog/2018/09/26/whats-new-for-apache-spark-on-kubernetes-in-the-upcoming-apache-spark-2-4-release.html</a></p>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/kubernetes/">kubernetes</category>
      
      <category domain="https://humbledude.github.io/blog/tags/spark/">spark</category>
      
      
      <comments>https://humbledude.github.io/blog/2018/12/01/spark-on-kube/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 2 - 전자칩 동작 원리</title>
      <link>https://humbledude.github.io/blog/2018/11/27/csforhuman-2/</link>
      <guid>https://humbledude.github.io/blog/2018/11/27/csforhuman-2/</guid>
      <pubDate>Mon, 26 Nov 2018 15:57:47 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이전 글에서 깃발을 올렸다 내렸다 하면서 숫자를 만들었다.&lt;br&gt;그럼 청기가 얼마나 올라가야 청기를 올린것으로 봐주나?&lt;/p&gt;
&lt;p&gt;명확하게 청기를 번쩍 들었을때는 모두 알 수 있다. 청기가 올라갔구나&lt;br&gt;그런데 그렇게 하면 사회자의 연속적인 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>이전 글에서 깃발을 올렸다 내렸다 하면서 숫자를 만들었다.<br>그럼 청기가 얼마나 올라가야 청기를 올린것으로 봐주나?</p><p>명확하게 청기를 번쩍 들었을때는 모두 알 수 있다. 청기가 올라갔구나<br>그런데 그렇게 하면 사회자의 연속적인 명령에 빠르게 반응하기가 어렵다.<br>최소한의 움직임으로 사회자를 만족시켜야 한다.<br>그런데 애매하게 청기를 꿈틀 하고 청기가 올라갔다고 우기다가 한대 맞았다면 이 억울함을 어찌해야 하나.</p><p>이걸 방지하기 위해 규칙을 정해보자. 팔꿈치보다 청기가 올라가면 올라간거고, 팔꿈치보다 내려가면 내려간거다.<br>팔꿈치와 일직선은 그냥 내려간거로 하자.</p><p>이제 규칙은 명확해졌고, 청기백기 고수라면 이것을 이용해 매우 작은 움직임 만으로도 청기백기 게임을 승리할수 있으리라.<br>대략 팔꿈치 근처에서 꿈틀 거리겠지.</p><p>요것이 전기를 0과 1로 바꾸는 방법이랑 비슷하다.<br>다양한 상태를 가질 수 있는걸 명확한 규칙을 적용해서 두가지 케이스로 만드는 거다.</p><p>피카츄의 백만볼트를 생각해보자.</p><img src="https://media.giphy.com/media/NfmqJkgxr6VEc/giphy.gif" class="" title="피카츄 백만볼트"><p>피카츄는 백만볼트 기술을 써서 로켓단을 무찌르는데, 로켓단이 하도 전기를 많이 맞아서 오십만 볼트까지는 맞아도 안날라간다고 치자.<br>근데 우리 피카츄는 백만볼트 기술을 쓰더라도 항상 백만볼트가 나가지는 않나보다.<br>배가고프다던가 몇대 맞았다던가 하면 좀 빠워가 약하다.</p><p>그래서 이렇게 된다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">피카츄 백만 볼트 -&gt; 로켓단 사망</span><br><span class="line">피카츄 구십구만 볼트 -&gt; 로켓단 사망</span><br><span class="line">…</span><br><span class="line">피카츄 오십일만 볼트 -&gt; 로켓단 사망</span><br><span class="line">피카츄 오십만 볼트 -&gt; 로켓단 생존</span><br><span class="line">…</span><br><span class="line">피카츄 만볼트 -&gt; 로켓단 생존</span><br></pre></td></tr></table></figure><p>피카츄의 전기(만볼트 ~ 백만볼트)가 로켓단 사망(0) , 생존(1) 으로 이어지는것이다.<br>피카츄는 다양한 컨디션을 갖지만, 결국 로켓단의 사망(0)과 생존(1)의 두가지 결론만 있다.</p><p>전자칩도 마찬가지다.</p><img src="/blog/2018/11/27/csforhuman-2/microchip.png" class="" title="전자칩 그림"><p>뭣에다 쓰는 전자칩인지는 모르겠지만 애벌레같이 생긴 이 전자칩의 다리를 통해 전기가 왔다갔다 하는데,<br>백만볼트는 아니지만 몇 볼트 보다 높게 들어가면 전자칩이 아 1이 들어왔구나 하고<br>그거보다 낮게 들어오면 아 0이 들어왔구나 한다.<br>(이 기준은 칩을 만든 회사에서 정하기도 하고, 표준이 있기도 하다)</p><p>물론 현실은 이거보다는 복잡하지만, 전자칩은 아무튼 전기로 0 과 1을 주고 받는구나 이렇게 생각하면 된다.<br>누구랑? 다른 전자칩이랑.</p><img src="/blog/2018/11/27/csforhuman-2/pcb.jpg" class="" title="회로 그림"><p>컴퓨터를 뜯어보면 이렇게 생긴 칩들이 많이 박혀있고, 하얀 선으로 서로 연결 되어있다.<br>이 선들중 대부분이 0 과 1이 왔다갔다 하는 통로 이다.<br>그리고 전자칩은 0과 1을 다양하게 조합해서 더 많은 숫자들로 인식 한다.</p><p>그러면 이 다양한 숫자가 오고가는게 컴퓨터에서 어떤 역할을 하는지 슬슬 알아 보자.</p><blockquote><p>연관 용어 : pull-up, pull-down, ic, bus, gpio</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%B4%ED%95%B4/">컴퓨터의 이해</category>
      
      
      <comments>https://humbledude.github.io/blog/2018/11/27/csforhuman-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 1 - 이진법</title>
      <link>https://humbledude.github.io/blog/2018/11/22/csforhuman-1-0-1/</link>
      <guid>https://humbledude.github.io/blog/2018/11/22/csforhuman-1-0-1/</guid>
      <pubDate>Thu, 22 Nov 2018 14:55:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;아무리 컴퓨터에 대해 잘 모르는 사람도  어디 지나가다가 컴퓨터는 0과 1을 가지고 뭘 했다는 소리 정도는 들었을 것이다.&lt;br&gt;컴퓨터는 기본적으로 0과 1을 가지고 동작하는 기계이다.&lt;br&gt;일단 그놈의 0과 1이 어쨌다는건지 알아보자.&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>아무리 컴퓨터에 대해 잘 모르는 사람도  어디 지나가다가 컴퓨터는 0과 1을 가지고 뭘 했다는 소리 정도는 들었을 것이다.<br>컴퓨터는 기본적으로 0과 1을 가지고 동작하는 기계이다.<br>일단 그놈의 0과 1이 어쨌다는건지 알아보자.</p><img src="/blog/2018/11/22/csforhuman-1-0-1/matrix-434035_640.jpg" class="" title="매트릭스 0과 1"><p>일단 청기 백기 게임을 떠올려 본다.<br>청기백기 게임을 모르는 청춘들은 유투브에서 한번 검색 해 보자.</p><img src="/blog/2018/11/22/csforhuman-1-0-1/blue-white.jpg" class="" title="청기백기"><p>청기 올려 라는 사회자의 명령에 청기를 올려 본다.<br>대략 틀리면 맞기도 하고 벌주를 먹기도 한다.<br>이거 하다보면 점점 빨리하는데 잘하는 사람은 진짜 빨리 반응을 잘한다.</p><p>요걸로 컴퓨터의 기본 숫자인 0 과 1을 표현해 볼것이다.</p><p>청기가 올라간것을 1, 내려간것을 0이라고 표현해 보자.<br>얼마나 올라갔는지 보다는 올라갔는지 내려갔는지만 알면 되는거다.<br>이제 0이랑 1을 깃발 하나로 표현할 수 있다는걸 알았다.</p><p>근데 2를 표현하고 싶으면 어떻게 해야 하나?<br>우리에겐 백기가 있다.<br>청기랑 백기를 조합하면 무려 3까지 표현할 수 있다.<br>대충 이런식이다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &#x3D; 청기 내려 백기 내려</span><br><span class="line">1 &#x3D; 청기 내려 백기 올려</span><br><span class="line">2 &#x3D; 청기 올려 백기 내려</span><br><span class="line">3 &#x3D; 청기 올려 백기 올려</span><br></pre></td></tr></table></figure><p>깃발 두개로 0 에서 3까지의 숫자를 표현할 수 있는 규칙을 만들었다.<br>그럼 청기백기를 든 아저씨를 몇명 더 데려오면 표현할 수 있는 숫자가 더 많아지겠지?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 &#x3D; 아저씨1 (청기 내려 백기 올려) 아저씨2 (청기 내려 백기 내려)</span><br><span class="line">5 &#x3D; 아저씨1 (청기 내려 백기 올려) 아저씨2 (청기 내려 백기 올려)</span><br></pre></td></tr></table></figure><p>혹자는 이것이 이진법이라는것을 알것이다.<br>이진법이란 쉽게 생각해서 0과 1, 두가지 숫자를 여러개 조합해서 우리가 이미 알고있는 다른 숫자를 표현하는 방법이다.<br>위에 나온 깃발든 아저씨들이 많이 모이면 얼마든지 더 큰 숫자도 표현할 수 있다.</p><p>참고로 아저씨들을 많이 모으지 않고 깃발 한개로 숫자를 더 표현하는 방법도 있다.<br>바로 시간차를 두고 순서대로 명령을 읊으면 된다.<br>청기 하나로 해보자 (고급 사회자는 이런 혼미한 명령을 잘 내린다)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &#x3D; 청기 내리고 청기 내려</span><br><span class="line">1 &#x3D; 청기 내리고 청기 올려</span><br><span class="line">2 &#x3D; 청기 올리고 청기 내려</span><br><span class="line">3 &#x3D; 청기 올리고 청기 올려</span><br></pre></td></tr></table></figure><p>사회자가 이 혼미한 말을 계속 읊으면 더 많은 숫자를 표현 할 수 있다는것을 기억하자.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">245 &#x3D; 청기 올리고 청기 내리고 청기 내리고 청기 올리고 청기 내리고 청기 내리고 청기 내리고 청기 올리고 청기 내리고 청기 올려!!!!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>그럼 오늘은 여기까지 하고 깃발 올린거랑 내린거랑 숫자랑 갖고 컴퓨터를 뭘 어쨌다는건지는 다음 글에서 알아보자.</p><blockquote><p>연관 용어 : 이진법, digital, serial, parallel</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%B4%ED%95%B4/">컴퓨터의 이해</category>
      
      
      <comments>https://humbledude.github.io/blog/2018/11/22/csforhuman-1-0-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 0 - 들어가는 말</title>
      <link>https://humbledude.github.io/blog/2018/11/22/csforhuman-0/</link>
      <guid>https://humbledude.github.io/blog/2018/11/22/csforhuman-0/</guid>
      <pubDate>Wed, 21 Nov 2018 15:26:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;저는 소프트웨어 개발을 업으로 하는 사람입니다.&lt;br&gt;일을 하다보면 개발자와 이야기 하는 일도 많지만,&lt;br&gt;개발자가 아닌 분들과 업무를 진행해야 하는 일도 많습니다.&lt;/p&gt;
&lt;p&gt;보통 기획자와 개발자의 커뮤니케이션이 상당히 어렵다고 하는데요,&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>저는 소프트웨어 개발을 업으로 하는 사람입니다.<br>일을 하다보면 개발자와 이야기 하는 일도 많지만,<br>개발자가 아닌 분들과 업무를 진행해야 하는 일도 많습니다.</p><p>보통 기획자와 개발자의 커뮤니케이션이 상당히 어렵다고 하는데요,<br>개발자는 보통 기획자가 알아듣기 어려운 기술 용어를 써가며 말을 하고<br>기획자는 추상적인 말을 사용하니, 서로의 의도를 정확히 파악하지 못하곤 합니다.</p><p>나름 커뮤니케이션에 문제가 없는 편이라고 자부하면서도,<br>막상 업무 관계에서 명확히 의사소통을 하는것은 항상 어려운 일입니다.</p><p>그들을 저는 휴먼 종족이라고 칭합니다.<br>개발자 종족과는 다른 언어와 종교를 갖고, 다른 세계에서 살고 있는것 처럼 보입니다.<br>저는 휴먼들에게 개발자와 소통하기 위해 개발자가 대체 뭘 배웠기에 이 지경이 되었는지 휴먼들이 이해할 수 있도록 설명하는게 어떨까 생각 했습니다.<br>그래서 이 글을 써 봅니다. 약간 전도지와 같습니다.<br>휴먼에서 개발자로 개종을 원하시는 분에게도 어렴풋이 도움이 되었으면 하네요.</p><p>목표는 정상적이고 매우 상식적인 사람들이 보고서 개발자들이 말하는 용어들을 대충 느낌적인 느낌으로 알아들을 수 있게 하는겁니다.<br>그렇게 하기 위해서 자세한 내용은 다 던져버리고 매우 핵심에 대한 내용을 매우 대충 다루며 지나갈 예정입니다.</p><p>그게 맘처럼 될지 모르겠으나,<br>어렵거나 이해가 안되는 내용은 알려주세요. 가능한 더 쉽게 설명해 보겠습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%B4%ED%95%B4/">컴퓨터의 이해</category>
      
      
      <comments>https://humbledude.github.io/blog/2018/11/22/csforhuman-0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySql 테이블 백업 &amp; 복구</title>
      <link>https://humbledude.github.io/blog/2018/11/16/mysql-backup-restore/</link>
      <guid>https://humbledude.github.io/blog/2018/11/16/mysql-backup-restore/</guid>
      <pubDate>Thu, 15 Nov 2018 18:09:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;백업&quot;&gt;&lt;a href=&quot;#백업&quot; class=&quot;headerlink&quot; title=&quot;백업&quot;&gt;&lt;/a&gt;백업&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="백업"><a href="#백업" class="headerlink" title="백업"></a>백업</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u USER_NAME -h HOST -p DB_NAME TABLE_NAME &gt; backup.sql</span><br></pre></td></tr></table></figure><p>*-p 는 패스워드 입력 옵션 *</p><h2 id="복구"><a href="#복구" class="headerlink" title="복구"></a>복구</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u USER_NAME -h HOST -p DB_NAME &lt; backup.sql</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/mysql/">mysql</category>
      
      
      <comments>https://humbledude.github.io/blog/2018/11/16/mysql-backup-restore/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>zsh &amp; bash locale 설정</title>
      <link>https://humbledude.github.io/blog/2018/11/16/zsh-bash-locale/</link>
      <guid>https://humbledude.github.io/blog/2018/11/16/zsh-bash-locale/</guid>
      <pubDate>Thu, 15 Nov 2018 18:05:51 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;mac os 에서 기본 bash 를 사용하고 있었고, 원격 서버로 ssh 접속했을 때, ssh 상에서 한글 표시가 문제 없었다</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>mac os 에서 기본 bash 를 사용하고 있었고, 원격 서버로 ssh 접속했을 때, ssh 상에서 한글 표시가 문제 없었다.</p><p>그런데 zsh 를 쓰고 원격 서버로 ssh 접속하니, 한글 표시가 문제가 되었다.</p><p>여기서 원격 서버는 bash 사용중.</p><h2 id="작업-내용"><a href="#작업-내용" class="headerlink" title="작업 내용"></a>작업 내용</h2><p>결국 locale 설정 문제다.<br>mac os 에서 locale 확인:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ locale</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=<span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br><span class="line">LC_CTYPE=<span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=<span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure><p>bash -&gt; 원격 서버 접속 후 locale 확인:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NAME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ADDRESS=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TELEPHONE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure><p>zsh -&gt; 원격 서버 접속 후 locale 확인:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale: Cannot <span class="built_in">set</span> LC_CTYPE to default locale: No such file or directory</span><br><span class="line">locale: Cannot <span class="built_in">set</span> LC_ALL to default locale: No such file or directory</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=ko_KR.UTF-8</span><br><span class="line">LC_NUMERIC=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NAME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ADDRESS=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TELEPHONE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure><p>원격 서버에서 아래와 같이 입력하면 이슈는 해결된다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo locale-gen <span class="string">&quot;ko_KR.UTF-8&quot;</span></span><br></pre></td></tr></table></figure><p>다시 locale 확인해보면~</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=ko_KR.UTF-8</span><br><span class="line">LC_NUMERIC=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NAME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ADDRESS=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TELEPHONE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure><p>LC_CTYPE 이 ko_KR.UTF-8 로 설정되고, ssh 에서 한글 사용이 자유롭게 되는것을 볼 수 있다.</p><h2 id="원인-분석"><a href="#원인-분석" class="headerlink" title="원인 분석"></a>원인 분석</h2><p>일단 LC_CTYPE 이게 뭔가?</p><p>gnu 정의 보면..</p><blockquote><p>This category applies to classification and conversion of characters, and to multibyte and wide characters;</p></blockquote><p>conversion 에 관여하는 항목이라고 보인다.</p><p>아직 정확히 파악은 안되었지만, ssh 통해서 지원하지 않는 locale 이 나타났을때 LC_CTYPE 기준으로 conversion 이 이루어진다고 보인다.</p><p>bash 는 뭔가 능숙히 터널링이 되었고, zsh 는 안되는건 안된다라고 표현한듯…</p>]]></content:encoded>
      
      
      
      <category domain="https://humbledude.github.io/blog/tags/zsh/">zsh</category>
      
      <category domain="https://humbledude.github.io/blog/tags/bash/">bash</category>
      
      <category domain="https://humbledude.github.io/blog/tags/locale/">locale</category>
      
      
      <comments>https://humbledude.github.io/blog/2018/11/16/zsh-bash-locale/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
